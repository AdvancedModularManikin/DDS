// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file AMMPubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastcdrgen.
 */


#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

#include "AMMPubSubTypes.h"

namespace AMM
{
    namespace Simulation
    {
        TickPubSubType::TickPubSubType() {
            setName("AMM::Simulation::Tick");
            m_typeSize = (uint32_t)Tick::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Tick::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Tick::getKeyMaxCdrSerializedSize()>16 ? Tick::getKeyMaxCdrSerializedSize() : 16);
        }

        TickPubSubType::~TickPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool TickPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Tick *p_type = (Tick*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool TickPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Tick* p_type = (Tick*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> TickPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Tick*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* TickPubSubType::createData() {
            return (void*)new Tick();
        }

        void TickPubSubType::deleteData(void* data) {
            delete((Tick*)data);
        }

        bool TickPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Tick* p_type = (Tick*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Tick::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Tick::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Simulation
    namespace Physiology
    {
        NodePubSubType::NodePubSubType() {
            setName("AMM::Physiology::Node");
            m_typeSize = (uint32_t)Node::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Node::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Node::getKeyMaxCdrSerializedSize()>16 ? Node::getKeyMaxCdrSerializedSize() : 16);
        }

        NodePubSubType::~NodePubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool NodePubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Node *p_type = (Node*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool NodePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Node* p_type = (Node*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> NodePubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Node*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* NodePubSubType::createData() {
            return (void*)new Node();
        }

        void NodePubSubType::deleteData(void* data) {
            delete((Node*)data);
        }

        bool NodePubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Node* p_type = (Node*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Node::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Node::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        HighFrequencyNodePubSubType::HighFrequencyNodePubSubType() {
            setName("AMM::Physiology::HighFrequencyNode");
            m_typeSize = (uint32_t)HighFrequencyNode::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = HighFrequencyNode::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(HighFrequencyNode::getKeyMaxCdrSerializedSize()>16 ? HighFrequencyNode::getKeyMaxCdrSerializedSize() : 16);
        }

        HighFrequencyNodePubSubType::~HighFrequencyNodePubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool HighFrequencyNodePubSubType::serialize(void *data, SerializedPayload_t *payload) {
            HighFrequencyNode *p_type = (HighFrequencyNode*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool HighFrequencyNodePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            HighFrequencyNode* p_type = (HighFrequencyNode*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> HighFrequencyNodePubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<HighFrequencyNode*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* HighFrequencyNodePubSubType::createData() {
            return (void*)new HighFrequencyNode();
        }

        void HighFrequencyNodePubSubType::deleteData(void* data) {
            delete((HighFrequencyNode*)data);
        }

        bool HighFrequencyNodePubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            HighFrequencyNode* p_type = (HighFrequencyNode*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,HighFrequencyNode::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(HighFrequencyNode::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Physiology
    namespace PatientAction
    {
        namespace BioGears
        {
            CommandPubSubType::CommandPubSubType() {
                setName("AMM::PatientAction::BioGears::Command");
                m_typeSize = (uint32_t)Command::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = Command::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(Command::getKeyMaxCdrSerializedSize()>16 ? Command::getKeyMaxCdrSerializedSize() : 16);
            }

            CommandPubSubType::~CommandPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool CommandPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                Command *p_type = (Command*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool CommandPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                Command* p_type = (Command*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> CommandPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<Command*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* CommandPubSubType::createData() {
                return (void*)new Command();
            }

            void CommandPubSubType::deleteData(void* data) {
                delete((Command*)data);
            }

            bool CommandPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                Command* p_type = (Command*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Command::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(Command::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }


        } //End of namespace BioGears

    } //End of namespace PatientAction
    namespace Performance
    {
        xAPIModifierPubSubType::xAPIModifierPubSubType() {
            setName("AMM::Performance::xAPIModifier");
            m_typeSize = (uint32_t)xAPIModifier::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = xAPIModifier::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(xAPIModifier::getKeyMaxCdrSerializedSize()>16 ? xAPIModifier::getKeyMaxCdrSerializedSize() : 16);
        }

        xAPIModifierPubSubType::~xAPIModifierPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool xAPIModifierPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            xAPIModifier *p_type = (xAPIModifier*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool xAPIModifierPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            xAPIModifier* p_type = (xAPIModifier*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> xAPIModifierPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<xAPIModifier*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* xAPIModifierPubSubType::createData() {
            return (void*)new xAPIModifier();
        }

        void xAPIModifierPubSubType::deleteData(void* data) {
            delete((xAPIModifier*)data);
        }

        bool xAPIModifierPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            xAPIModifier* p_type = (xAPIModifier*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,xAPIModifier::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(xAPIModifier::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


        StatementPubSubType::StatementPubSubType() {
            setName("AMM::Performance::Statement");
            m_typeSize = (uint32_t)Statement::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Statement::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Statement::getKeyMaxCdrSerializedSize()>16 ? Statement::getKeyMaxCdrSerializedSize() : 16);
        }

        StatementPubSubType::~StatementPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool StatementPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Statement *p_type = (Statement*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool StatementPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Statement* p_type = (Statement*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> StatementPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Statement*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* StatementPubSubType::createData() {
            return (void*)new Statement();
        }

        void StatementPubSubType::deleteData(void* data) {
            delete((Statement*)data);
        }

        bool StatementPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Statement* p_type = (Statement*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Statement::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Statement::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Performance
    namespace Sys
    {
        namespace Log
        {
            infoPubSubType::infoPubSubType() {
                setName("AMM::Sys::Log::info");
                m_typeSize = (uint32_t)info::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = info::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(info::getKeyMaxCdrSerializedSize()>16 ? info::getKeyMaxCdrSerializedSize() : 16);
            }

            infoPubSubType::~infoPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool infoPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                info *p_type = (info*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool infoPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                info* p_type = (info*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> infoPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<info*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* infoPubSubType::createData() {
                return (void*)new info();
            }

            void infoPubSubType::deleteData(void* data) {
                delete((info*)data);
            }

            bool infoPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                info* p_type = (info*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,info::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(info::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            warningPubSubType::warningPubSubType() {
                setName("AMM::Sys::Log::warning");
                m_typeSize = (uint32_t)warning::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = warning::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(warning::getKeyMaxCdrSerializedSize()>16 ? warning::getKeyMaxCdrSerializedSize() : 16);
            }

            warningPubSubType::~warningPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool warningPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                warning *p_type = (warning*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool warningPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                warning* p_type = (warning*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> warningPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<warning*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* warningPubSubType::createData() {
                return (void*)new warning();
            }

            void warningPubSubType::deleteData(void* data) {
                delete((warning*)data);
            }

            bool warningPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                warning* p_type = (warning*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,warning::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(warning::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            errorPubSubType::errorPubSubType() {
                setName("AMM::Sys::Log::error");
                m_typeSize = (uint32_t)error::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = error::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(error::getKeyMaxCdrSerializedSize()>16 ? error::getKeyMaxCdrSerializedSize() : 16);
            }

            errorPubSubType::~errorPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool errorPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                error *p_type = (error*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool errorPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                error* p_type = (error*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> errorPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<error*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* errorPubSubType::createData() {
                return (void*)new error();
            }

            void errorPubSubType::deleteData(void* data) {
                delete((error*)data);
            }

            bool errorPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                error* p_type = (error*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,error::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(error::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            debugPubSubType::debugPubSubType() {
                setName("AMM::Sys::Log::debug");
                m_typeSize = (uint32_t)debug::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = debug::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(debug::getKeyMaxCdrSerializedSize()>16 ? debug::getKeyMaxCdrSerializedSize() : 16);
            }

            debugPubSubType::~debugPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool debugPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                debug *p_type = (debug*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool debugPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                debug* p_type = (debug*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> debugPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<debug*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* debugPubSubType::createData() {
                return (void*)new debug();
            }

            void debugPubSubType::deleteData(void* data) {
                delete((debug*)data);
            }

            bool debugPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                debug* p_type = (debug*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,debug::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(debug::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }


        } //End of namespace Log

    } //End of namespace Sys

} //End of namespace AMM
