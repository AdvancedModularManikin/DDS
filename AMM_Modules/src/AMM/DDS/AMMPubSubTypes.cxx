// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file AMMPubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastcdrgen.
 */


#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

#include "AMMPubSubTypes.h"

using namespace eprosima::fastrtps;
using namespace eprosima::fastrtps::rtps;

FMA_LocationPubSubType::FMA_LocationPubSubType() {
    setName("FMA_Location");
    m_typeSize = (uint32_t)FMA_Location::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = FMA_Location::isKeyDefined();
    m_keyBuffer = (unsigned char*)malloc(FMA_Location::getKeyMaxCdrSerializedSize()>16 ? FMA_Location::getKeyMaxCdrSerializedSize() : 16);
}

FMA_LocationPubSubType::~FMA_LocationPubSubType() {
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool FMA_LocationPubSubType::serialize(void *data, SerializedPayload_t *payload) {
    FMA_Location *p_type = (FMA_Location*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool FMA_LocationPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
    FMA_Location* p_type = (FMA_Location*) data; 	//Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> FMA_LocationPubSubType::getSerializedSizeProvider(void* data) {
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<FMA_Location*>(data)) + 4 /*encapsulation*/;
    };
}

void* FMA_LocationPubSubType::createData() {
    return (void*)new FMA_Location();
}

void FMA_LocationPubSubType::deleteData(void* data) {
    delete((FMA_Location*)data);
}

bool FMA_LocationPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    FMA_Location* p_type = (FMA_Location*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,FMA_Location::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
    p_type->serializeKey(ser);
    if(FMA_Location::getKeyMaxCdrSerializedSize()>16)	{
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)    	{
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)    	{
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

UUIDPubSubType::UUIDPubSubType() {
    setName("UUID");
    m_typeSize = (uint32_t)UUID::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
    m_isGetKeyDefined = UUID::isKeyDefined();
    m_keyBuffer = (unsigned char*)malloc(UUID::getKeyMaxCdrSerializedSize()>16 ? UUID::getKeyMaxCdrSerializedSize() : 16);
}

UUIDPubSubType::~UUIDPubSubType() {
    if(m_keyBuffer!=nullptr)
        free(m_keyBuffer);
}

bool UUIDPubSubType::serialize(void *data, SerializedPayload_t *payload) {
    UUID *p_type = (UUID*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
    payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
    // Serialize encapsulation
    ser.serialize_encapsulation();

    try
    {
        p_type->serialize(ser); // Serialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
    return true;
}

bool UUIDPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
    UUID* p_type = (UUID*) data; 	//Convert DATA to pointer of your type
    eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
    eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
            eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
    // Deserialize encapsulation.
    deser.read_encapsulation();
    payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

    try
    {
        p_type->deserialize(deser); //Deserialize the object:
    }
    catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
    {
        return false;
    }

    return true;
}

std::function<uint32_t()> UUIDPubSubType::getSerializedSizeProvider(void* data) {
    return [data]() -> uint32_t
    {
        return (uint32_t)type::getCdrSerializedSize(*static_cast<UUID*>(data)) + 4 /*encapsulation*/;
    };
}

void* UUIDPubSubType::createData() {
    return (void*)new UUID();
}

void UUIDPubSubType::deleteData(void* data) {
    delete((UUID*)data);
}

bool UUIDPubSubType::getKey(void *data, InstanceHandle_t* handle) {
    if(!m_isGetKeyDefined)
        return false;
    UUID* p_type = (UUID*) data;
    eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,UUID::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
    eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
    p_type->serializeKey(ser);
    if(UUID::getKeyMaxCdrSerializedSize()>16)	{
        m_md5.init();
        m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
        m_md5.finalize();
        for(uint8_t i = 0;i<16;++i)    	{
            handle->value[i] = m_md5.digest[i];
        }
    }
    else    {
        for(uint8_t i = 0;i<16;++i)    	{
            handle->value[i] = m_keyBuffer[i];
        }
    }
    return true;
}

namespace AMM
{
    namespace Event
    {
        FragmentPubSubType::FragmentPubSubType() {
            setName("AMM::Event::Fragment");
            m_typeSize = (uint32_t)Fragment::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Fragment::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Fragment::getKeyMaxCdrSerializedSize()>16 ? Fragment::getKeyMaxCdrSerializedSize() : 16);
        }

        FragmentPubSubType::~FragmentPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool FragmentPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Fragment *p_type = (Fragment*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool FragmentPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Fragment* p_type = (Fragment*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> FragmentPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Fragment*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* FragmentPubSubType::createData() {
            return (void*)new Fragment();
        }

        void FragmentPubSubType::deleteData(void* data) {
            delete((Fragment*)data);
        }

        bool FragmentPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Fragment* p_type = (Fragment*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Fragment::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Fragment::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        FragmentAmendmentRequestPubSubType::FragmentAmendmentRequestPubSubType() {
            setName("AMM::Event::FragmentAmendmentRequest");
            m_typeSize = (uint32_t)FragmentAmendmentRequest::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = FragmentAmendmentRequest::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(FragmentAmendmentRequest::getKeyMaxCdrSerializedSize()>16 ? FragmentAmendmentRequest::getKeyMaxCdrSerializedSize() : 16);
        }

        FragmentAmendmentRequestPubSubType::~FragmentAmendmentRequestPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool FragmentAmendmentRequestPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            FragmentAmendmentRequest *p_type = (FragmentAmendmentRequest*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool FragmentAmendmentRequestPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            FragmentAmendmentRequest* p_type = (FragmentAmendmentRequest*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> FragmentAmendmentRequestPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<FragmentAmendmentRequest*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* FragmentAmendmentRequestPubSubType::createData() {
            return (void*)new FragmentAmendmentRequest();
        }

        void FragmentAmendmentRequestPubSubType::deleteData(void* data) {
            delete((FragmentAmendmentRequest*)data);
        }

        bool FragmentAmendmentRequestPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            FragmentAmendmentRequest* p_type = (FragmentAmendmentRequest*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,FragmentAmendmentRequest::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(FragmentAmendmentRequest::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        RecordPubSubType::RecordPubSubType() {
            setName("AMM::Event::Record");
            m_typeSize = (uint32_t)Record::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Record::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Record::getKeyMaxCdrSerializedSize()>16 ? Record::getKeyMaxCdrSerializedSize() : 16);
        }

        RecordPubSubType::~RecordPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool RecordPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Record *p_type = (Record*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool RecordPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Record* p_type = (Record*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> RecordPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Record*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* RecordPubSubType::createData() {
            return (void*)new Record();
        }

        void RecordPubSubType::deleteData(void* data) {
            delete((Record*)data);
        }

        bool RecordPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Record* p_type = (Record*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Record::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Record::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Event
    namespace Environment
    {
        SettingsPubSubType::SettingsPubSubType() {
            setName("AMM::Environment::Settings");
            m_typeSize = (uint32_t)Settings::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Settings::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Settings::getKeyMaxCdrSerializedSize()>16 ? Settings::getKeyMaxCdrSerializedSize() : 16);
        }

        SettingsPubSubType::~SettingsPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool SettingsPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Settings *p_type = (Settings*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool SettingsPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Settings* p_type = (Settings*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> SettingsPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Settings*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* SettingsPubSubType::createData() {
            return (void*)new Settings();
        }

        void SettingsPubSubType::deleteData(void* data) {
            delete((Settings*)data);
        }

        bool SettingsPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Settings* p_type = (Settings*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Settings::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Settings::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Environment
    namespace Simulation
    {
        TickPubSubType::TickPubSubType() {
            setName("AMM::Simulation::Tick");
            m_typeSize = (uint32_t)Tick::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Tick::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Tick::getKeyMaxCdrSerializedSize()>16 ? Tick::getKeyMaxCdrSerializedSize() : 16);
        }

        TickPubSubType::~TickPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool TickPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Tick *p_type = (Tick*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool TickPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Tick* p_type = (Tick*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> TickPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Tick*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* TickPubSubType::createData() {
            return (void*)new Tick();
        }

        void TickPubSubType::deleteData(void* data) {
            delete((Tick*)data);
        }

        bool TickPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Tick* p_type = (Tick*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Tick::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Tick::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Simulation
    InstrumentDataPubSubType::InstrumentDataPubSubType() {
        setName("AMM::InstrumentData");
        m_typeSize = (uint32_t)InstrumentData::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
        m_isGetKeyDefined = InstrumentData::isKeyDefined();
        m_keyBuffer = (unsigned char*)malloc(InstrumentData::getKeyMaxCdrSerializedSize()>16 ? InstrumentData::getKeyMaxCdrSerializedSize() : 16);
    }

    InstrumentDataPubSubType::~InstrumentDataPubSubType() {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool InstrumentDataPubSubType::serialize(void *data, SerializedPayload_t *payload) {
        InstrumentData *p_type = (InstrumentData*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
        return true;
    }

    bool InstrumentDataPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
        InstrumentData* p_type = (InstrumentData*) data; 	//Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> InstrumentDataPubSubType::getSerializedSizeProvider(void* data) {
        return [data]() -> uint32_t
        {
            return (uint32_t)type::getCdrSerializedSize(*static_cast<InstrumentData*>(data)) + 4 /*encapsulation*/;
        };
    }

    void* InstrumentDataPubSubType::createData() {
        return (void*)new InstrumentData();
    }

    void InstrumentDataPubSubType::deleteData(void* data) {
        delete((InstrumentData*)data);
    }

    bool InstrumentDataPubSubType::getKey(void *data, InstanceHandle_t* handle) {
        if(!m_isGetKeyDefined)
            return false;
        InstrumentData* p_type = (InstrumentData*) data;
        eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,InstrumentData::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
        p_type->serializeKey(ser);
        if(InstrumentData::getKeyMaxCdrSerializedSize()>16)	{
            m_md5.init();
            m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)    	{
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    namespace Physiology
    {


        CommandPubSubType::CommandPubSubType() {
            setName("AMM::Physiology::Command");
            m_typeSize = (uint32_t)Command::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Command::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Command::getKeyMaxCdrSerializedSize()>16 ? Command::getKeyMaxCdrSerializedSize() : 16);
        }

        CommandPubSubType::~CommandPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool CommandPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Command *p_type = (Command*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool CommandPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Command* p_type = (Command*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> CommandPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Command*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* CommandPubSubType::createData() {
            return (void*)new Command();
        }

        void CommandPubSubType::deleteData(void* data) {
            delete((Command*)data);
        }

        bool CommandPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Command* p_type = (Command*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Command::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Command::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        namespace PainStimulus
        {
            DataPubSubType::DataPubSubType() {
                setName("AMM::Physiology::PainStimulus::Data");
                m_typeSize = (uint32_t)Data::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = Data::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(Data::getKeyMaxCdrSerializedSize()>16 ? Data::getKeyMaxCdrSerializedSize() : 16);
            }

            DataPubSubType::~DataPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool DataPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                Data *p_type = (Data*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool DataPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                Data* p_type = (Data*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> DataPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<Data*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* DataPubSubType::createData() {
                return (void*)new Data();
            }

            void DataPubSubType::deleteData(void* data) {
                delete((Data*)data);
            }

            bool DataPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                Data* p_type = (Data*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Data::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(Data::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }


        } //End of namespace PainStimulus
        namespace Sepsis
        {
            DataPubSubType::DataPubSubType() {
                setName("AMM::Physiology::Sepsis::Data");
                m_typeSize = (uint32_t)Data::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = Data::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(Data::getKeyMaxCdrSerializedSize()>16 ? Data::getKeyMaxCdrSerializedSize() : 16);
            }

            DataPubSubType::~DataPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool DataPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                Data *p_type = (Data*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool DataPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                Data* p_type = (Data*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> DataPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<Data*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* DataPubSubType::createData() {
                return (void*)new Data();
            }

            void DataPubSubType::deleteData(void* data) {
                delete((Data*)data);
            }

            bool DataPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                Data* p_type = (Data*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Data::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(Data::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }


        } //End of namespace Sepsis
        ModificationPubSubType::ModificationPubSubType() {
            setName("AMM::Physiology::Modification");
            m_typeSize = (uint32_t)Modification::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Modification::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Modification::getKeyMaxCdrSerializedSize()>16 ? Modification::getKeyMaxCdrSerializedSize() : 16);
        }

        ModificationPubSubType::~ModificationPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool ModificationPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Modification *p_type = (Modification*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool ModificationPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Modification* p_type = (Modification*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> ModificationPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Modification*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* ModificationPubSubType::createData() {
            return (void*)new Modification();
        }

        void ModificationPubSubType::deleteData(void* data) {
            delete((Modification*)data);
        }

        bool ModificationPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Modification* p_type = (Modification*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Modification::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Modification::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        NodePubSubType::NodePubSubType() {
            setName("AMM::Physiology::Node");
            m_typeSize = (uint32_t)Node::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Node::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Node::getKeyMaxCdrSerializedSize()>16 ? Node::getKeyMaxCdrSerializedSize() : 16);
        }

        NodePubSubType::~NodePubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool NodePubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Node *p_type = (Node*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool NodePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Node* p_type = (Node*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> NodePubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Node*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* NodePubSubType::createData() {
            return (void*)new Node();
        }

        void NodePubSubType::deleteData(void* data) {
            delete((Node*)data);
        }

        bool NodePubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Node* p_type = (Node*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Node::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Node::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        HighFrequencyNodePubSubType::HighFrequencyNodePubSubType() {
            setName("AMM::Physiology::HighFrequencyNode");
            m_typeSize = (uint32_t)HighFrequencyNode::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = HighFrequencyNode::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(HighFrequencyNode::getKeyMaxCdrSerializedSize()>16 ? HighFrequencyNode::getKeyMaxCdrSerializedSize() : 16);
        }

        HighFrequencyNodePubSubType::~HighFrequencyNodePubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool HighFrequencyNodePubSubType::serialize(void *data, SerializedPayload_t *payload) {
            HighFrequencyNode *p_type = (HighFrequencyNode*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool HighFrequencyNodePubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            HighFrequencyNode* p_type = (HighFrequencyNode*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> HighFrequencyNodePubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<HighFrequencyNode*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* HighFrequencyNodePubSubType::createData() {
            return (void*)new HighFrequencyNode();
        }

        void HighFrequencyNodePubSubType::deleteData(void* data) {
            delete((HighFrequencyNode*)data);
        }

        bool HighFrequencyNodePubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            HighFrequencyNode* p_type = (HighFrequencyNode*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,HighFrequencyNode::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(HighFrequencyNode::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Physiology
    namespace Render
    {
        ModificationPubSubType::ModificationPubSubType() {
            setName("AMM::Render::Modification");
            m_typeSize = (uint32_t)Modification::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Modification::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Modification::getKeyMaxCdrSerializedSize()>16 ? Modification::getKeyMaxCdrSerializedSize() : 16);
        }

        ModificationPubSubType::~ModificationPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool ModificationPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Modification *p_type = (Modification*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool ModificationPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Modification* p_type = (Modification*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> ModificationPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Modification*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* ModificationPubSubType::createData() {
            return (void*)new Modification();
        }

        void ModificationPubSubType::deleteData(void* data) {
            delete((Modification*)data);
        }

        bool ModificationPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Modification* p_type = (Modification*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Modification::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Modification::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Render
    namespace PatientAction
    {
        namespace BioGears
        {
            CommandPubSubType::CommandPubSubType() {
                setName("AMM::PatientAction::BioGears::Command");
                m_typeSize = (uint32_t)Command::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = Command::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(Command::getKeyMaxCdrSerializedSize()>16 ? Command::getKeyMaxCdrSerializedSize() : 16);
            }

            CommandPubSubType::~CommandPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool CommandPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                Command *p_type = (Command*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool CommandPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                Command* p_type = (Command*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> CommandPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<Command*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* CommandPubSubType::createData() {
                return (void*)new Command();
            }

            void CommandPubSubType::deleteData(void* data) {
                delete((Command*)data);
            }

            bool CommandPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                Command* p_type = (Command*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Command::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(Command::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }


        } //End of namespace BioGears

    } //End of namespace PatientAction
    namespace Performance
    {
        xAPIModifierPubSubType::xAPIModifierPubSubType() {
            setName("AMM::Performance::xAPIModifier");
            m_typeSize = (uint32_t)xAPIModifier::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = xAPIModifier::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(xAPIModifier::getKeyMaxCdrSerializedSize()>16 ? xAPIModifier::getKeyMaxCdrSerializedSize() : 16);
        }

        xAPIModifierPubSubType::~xAPIModifierPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool xAPIModifierPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            xAPIModifier *p_type = (xAPIModifier*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool xAPIModifierPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            xAPIModifier* p_type = (xAPIModifier*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> xAPIModifierPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<xAPIModifier*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* xAPIModifierPubSubType::createData() {
            return (void*)new xAPIModifier();
        }

        void xAPIModifierPubSubType::deleteData(void* data) {
            delete((xAPIModifier*)data);
        }

        bool xAPIModifierPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            xAPIModifier* p_type = (xAPIModifier*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,xAPIModifier::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(xAPIModifier::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


        StatementPubSubType::StatementPubSubType() {
            setName("AMM::Performance::Statement");
            m_typeSize = (uint32_t)Statement::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Statement::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Statement::getKeyMaxCdrSerializedSize()>16 ? Statement::getKeyMaxCdrSerializedSize() : 16);
        }

        StatementPubSubType::~StatementPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool StatementPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Statement *p_type = (Statement*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool StatementPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Statement* p_type = (Statement*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> StatementPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Statement*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* StatementPubSubType::createData() {
            return (void*)new Statement();
        }

        void StatementPubSubType::deleteData(void* data) {
            delete((Statement*)data);
        }

        bool StatementPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Statement* p_type = (Statement*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Statement::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Statement::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        AssessmentPubSubType::AssessmentPubSubType() {
            setName("AMM::Performance::Assessment");
            m_typeSize = (uint32_t)Assessment::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Assessment::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Assessment::getKeyMaxCdrSerializedSize()>16 ? Assessment::getKeyMaxCdrSerializedSize() : 16);
        }

        AssessmentPubSubType::~AssessmentPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool AssessmentPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Assessment *p_type = (Assessment*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool AssessmentPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Assessment* p_type = (Assessment*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> AssessmentPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Assessment*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* AssessmentPubSubType::createData() {
            return (void*)new Assessment();
        }

        void AssessmentPubSubType::deleteData(void* data) {
            delete((Assessment*)data);
        }

        bool AssessmentPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Assessment* p_type = (Assessment*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Assessment::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Assessment::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Performance
    namespace Resource
    {
        namespace Requirement
        {
            PowerPubSubType::PowerPubSubType() {
                setName("AMM::Resource::Requirement::Power");
                m_typeSize = (uint32_t)Power::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = Power::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(Power::getKeyMaxCdrSerializedSize()>16 ? Power::getKeyMaxCdrSerializedSize() : 16);
            }

            PowerPubSubType::~PowerPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool PowerPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                Power *p_type = (Power*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool PowerPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                Power* p_type = (Power*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> PowerPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<Power*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* PowerPubSubType::createData() {
                return (void*)new Power();
            }

            void PowerPubSubType::deleteData(void* data) {
                delete((Power*)data);
            }

            bool PowerPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                Power* p_type = (Power*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Power::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(Power::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            BloodPubSubType::BloodPubSubType() {
                setName("AMM::Resource::Requirement::Blood");
                m_typeSize = (uint32_t)Blood::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = Blood::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(Blood::getKeyMaxCdrSerializedSize()>16 ? Blood::getKeyMaxCdrSerializedSize() : 16);
            }

            BloodPubSubType::~BloodPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool BloodPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                Blood *p_type = (Blood*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool BloodPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                Blood* p_type = (Blood*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> BloodPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<Blood*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* BloodPubSubType::createData() {
                return (void*)new Blood();
            }

            void BloodPubSubType::deleteData(void* data) {
                delete((Blood*)data);
            }

            bool BloodPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                Blood* p_type = (Blood*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Blood::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(Blood::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            Clear_LiquidPubSubType::Clear_LiquidPubSubType() {
                setName("AMM::Resource::Requirement::Clear_Liquid");
                m_typeSize = (uint32_t)Clear_Liquid::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = Clear_Liquid::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(Clear_Liquid::getKeyMaxCdrSerializedSize()>16 ? Clear_Liquid::getKeyMaxCdrSerializedSize() : 16);
            }

            Clear_LiquidPubSubType::~Clear_LiquidPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool Clear_LiquidPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                Clear_Liquid *p_type = (Clear_Liquid*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool Clear_LiquidPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                Clear_Liquid* p_type = (Clear_Liquid*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> Clear_LiquidPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<Clear_Liquid*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* Clear_LiquidPubSubType::createData() {
                return (void*)new Clear_Liquid();
            }

            void Clear_LiquidPubSubType::deleteData(void* data) {
                delete((Clear_Liquid*)data);
            }

            bool Clear_LiquidPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                Clear_Liquid* p_type = (Clear_Liquid*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Clear_Liquid::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(Clear_Liquid::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            AirPubSubType::AirPubSubType() {
                setName("AMM::Resource::Requirement::Air");
                m_typeSize = (uint32_t)Air::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = Air::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(Air::getKeyMaxCdrSerializedSize()>16 ? Air::getKeyMaxCdrSerializedSize() : 16);
            }

            AirPubSubType::~AirPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool AirPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                Air *p_type = (Air*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool AirPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                Air* p_type = (Air*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> AirPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<Air*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* AirPubSubType::createData() {
                return (void*)new Air();
            }

            void AirPubSubType::deleteData(void* data) {
                delete((Air*)data);
            }

            bool AirPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                Air* p_type = (Air*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Air::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(Air::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            Cleaning_SolutionPubSubType::Cleaning_SolutionPubSubType() {
                setName("AMM::Resource::Requirement::Cleaning_Solution");
                m_typeSize = (uint32_t)Cleaning_Solution::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = Cleaning_Solution::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(Cleaning_Solution::getKeyMaxCdrSerializedSize()>16 ? Cleaning_Solution::getKeyMaxCdrSerializedSize() : 16);
            }

            Cleaning_SolutionPubSubType::~Cleaning_SolutionPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool Cleaning_SolutionPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                Cleaning_Solution *p_type = (Cleaning_Solution*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool Cleaning_SolutionPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                Cleaning_Solution* p_type = (Cleaning_Solution*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> Cleaning_SolutionPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<Cleaning_Solution*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* Cleaning_SolutionPubSubType::createData() {
                return (void*)new Cleaning_Solution();
            }

            void Cleaning_SolutionPubSubType::deleteData(void* data) {
                delete((Cleaning_Solution*)data);
            }

            bool Cleaning_SolutionPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                Cleaning_Solution* p_type = (Cleaning_Solution*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Cleaning_Solution::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(Cleaning_Solution::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }


        } //End of namespace Requirement
        namespace Supply
        {
            PowerPubSubType::PowerPubSubType() {
                setName("AMM::Resource::Supply::Power");
                m_typeSize = (uint32_t)Power::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = Power::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(Power::getKeyMaxCdrSerializedSize()>16 ? Power::getKeyMaxCdrSerializedSize() : 16);
            }

            PowerPubSubType::~PowerPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool PowerPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                Power *p_type = (Power*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool PowerPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                Power* p_type = (Power*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> PowerPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<Power*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* PowerPubSubType::createData() {
                return (void*)new Power();
            }

            void PowerPubSubType::deleteData(void* data) {
                delete((Power*)data);
            }

            bool PowerPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                Power* p_type = (Power*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Power::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(Power::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            BloodPubSubType::BloodPubSubType() {
                setName("AMM::Resource::Supply::Blood");
                m_typeSize = (uint32_t)Blood::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = Blood::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(Blood::getKeyMaxCdrSerializedSize()>16 ? Blood::getKeyMaxCdrSerializedSize() : 16);
            }

            BloodPubSubType::~BloodPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool BloodPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                Blood *p_type = (Blood*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool BloodPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                Blood* p_type = (Blood*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> BloodPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<Blood*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* BloodPubSubType::createData() {
                return (void*)new Blood();
            }

            void BloodPubSubType::deleteData(void* data) {
                delete((Blood*)data);
            }

            bool BloodPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                Blood* p_type = (Blood*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Blood::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(Blood::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            Clear_LiquidPubSubType::Clear_LiquidPubSubType() {
                setName("AMM::Resource::Supply::Clear_Liquid");
                m_typeSize = (uint32_t)Clear_Liquid::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = Clear_Liquid::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(Clear_Liquid::getKeyMaxCdrSerializedSize()>16 ? Clear_Liquid::getKeyMaxCdrSerializedSize() : 16);
            }

            Clear_LiquidPubSubType::~Clear_LiquidPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool Clear_LiquidPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                Clear_Liquid *p_type = (Clear_Liquid*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool Clear_LiquidPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                Clear_Liquid* p_type = (Clear_Liquid*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> Clear_LiquidPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<Clear_Liquid*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* Clear_LiquidPubSubType::createData() {
                return (void*)new Clear_Liquid();
            }

            void Clear_LiquidPubSubType::deleteData(void* data) {
                delete((Clear_Liquid*)data);
            }

            bool Clear_LiquidPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                Clear_Liquid* p_type = (Clear_Liquid*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Clear_Liquid::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(Clear_Liquid::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            AirPubSubType::AirPubSubType() {
                setName("AMM::Resource::Supply::Air");
                m_typeSize = (uint32_t)Air::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = Air::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(Air::getKeyMaxCdrSerializedSize()>16 ? Air::getKeyMaxCdrSerializedSize() : 16);
            }

            AirPubSubType::~AirPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool AirPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                Air *p_type = (Air*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool AirPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                Air* p_type = (Air*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> AirPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<Air*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* AirPubSubType::createData() {
                return (void*)new Air();
            }

            void AirPubSubType::deleteData(void* data) {
                delete((Air*)data);
            }

            bool AirPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                Air* p_type = (Air*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Air::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(Air::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            Cleaning_SolutionPubSubType::Cleaning_SolutionPubSubType() {
                setName("AMM::Resource::Supply::Cleaning_Solution");
                m_typeSize = (uint32_t)Cleaning_Solution::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
                m_isGetKeyDefined = Cleaning_Solution::isKeyDefined();
                m_keyBuffer = (unsigned char*)malloc(Cleaning_Solution::getKeyMaxCdrSerializedSize()>16 ? Cleaning_Solution::getKeyMaxCdrSerializedSize() : 16);
            }

            Cleaning_SolutionPubSubType::~Cleaning_SolutionPubSubType() {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool Cleaning_SolutionPubSubType::serialize(void *data, SerializedPayload_t *payload) {
                Cleaning_Solution *p_type = (Cleaning_Solution*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
                return true;
            }

            bool Cleaning_SolutionPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
                Cleaning_Solution* p_type = (Cleaning_Solution*) data; 	//Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> Cleaning_SolutionPubSubType::getSerializedSizeProvider(void* data) {
                return [data]() -> uint32_t
                {
                    return (uint32_t)type::getCdrSerializedSize(*static_cast<Cleaning_Solution*>(data)) + 4 /*encapsulation*/;
                };
            }

            void* Cleaning_SolutionPubSubType::createData() {
                return (void*)new Cleaning_Solution();
            }

            void Cleaning_SolutionPubSubType::deleteData(void* data) {
                delete((Cleaning_Solution*)data);
            }

            bool Cleaning_SolutionPubSubType::getKey(void *data, InstanceHandle_t* handle) {
                if(!m_isGetKeyDefined)
                    return false;
                Cleaning_Solution* p_type = (Cleaning_Solution*) data;
                eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Cleaning_Solution::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
                p_type->serializeKey(ser);
                if(Cleaning_Solution::getKeyMaxCdrSerializedSize()>16)	{
                    m_md5.init();
                    m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)    	{
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }


        } //End of namespace Supply

    } //End of namespace Resource
    namespace Capability
    {

        AMM_versionPubSubType::AMM_versionPubSubType() {
            setName("AMM::Capability::AMM_version");
            m_typeSize = (uint32_t)AMM_version::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = AMM_version::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(AMM_version::getKeyMaxCdrSerializedSize()>16 ? AMM_version::getKeyMaxCdrSerializedSize() : 16);
        }

        AMM_versionPubSubType::~AMM_versionPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool AMM_versionPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            AMM_version *p_type = (AMM_version*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool AMM_versionPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            AMM_version* p_type = (AMM_version*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> AMM_versionPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<AMM_version*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* AMM_versionPubSubType::createData() {
            return (void*)new AMM_version();
        }

        void AMM_versionPubSubType::deleteData(void* data) {
            delete((AMM_version*)data);
        }

        bool AMM_versionPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            AMM_version* p_type = (AMM_version*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,AMM_version::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(AMM_version::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        ConfigurationPubSubType::ConfigurationPubSubType() {
            setName("AMM::Capability::Configuration");
            m_typeSize = (uint32_t)Configuration::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Configuration::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Configuration::getKeyMaxCdrSerializedSize()>16 ? Configuration::getKeyMaxCdrSerializedSize() : 16);
        }

        ConfigurationPubSubType::~ConfigurationPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool ConfigurationPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Configuration *p_type = (Configuration*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool ConfigurationPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Configuration* p_type = (Configuration*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> ConfigurationPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Configuration*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* ConfigurationPubSubType::createData() {
            return (void*)new Configuration();
        }

        void ConfigurationPubSubType::deleteData(void* data) {
            delete((Configuration*)data);
        }

        bool ConfigurationPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Configuration* p_type = (Configuration*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Configuration::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Configuration::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        ScenarioPubSubType::ScenarioPubSubType() {
            setName("AMM::Capability::Scenario");
            m_typeSize = (uint32_t)Scenario::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Scenario::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Scenario::getKeyMaxCdrSerializedSize()>16 ? Scenario::getKeyMaxCdrSerializedSize() : 16);
        }

        ScenarioPubSubType::~ScenarioPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool ScenarioPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Scenario *p_type = (Scenario*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool ScenarioPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Scenario* p_type = (Scenario*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> ScenarioPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Scenario*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* ScenarioPubSubType::createData() {
            return (void*)new Scenario();
        }

        void ScenarioPubSubType::deleteData(void* data) {
            delete((Scenario*)data);
        }

        bool ScenarioPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Scenario* p_type = (Scenario*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Scenario::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Scenario::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        StatusPubSubType::StatusPubSubType() {
            setName("AMM::Capability::Status");
            m_typeSize = (uint32_t)Status::getMaxCdrSerializedSize() + 4 /*encapsulation*/;
            m_isGetKeyDefined = Status::isKeyDefined();
            m_keyBuffer = (unsigned char*)malloc(Status::getKeyMaxCdrSerializedSize()>16 ? Status::getKeyMaxCdrSerializedSize() : 16);
        }

        StatusPubSubType::~StatusPubSubType() {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool StatusPubSubType::serialize(void *data, SerializedPayload_t *payload) {
            Status *p_type = (Status*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*) payload->data, payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = (uint32_t)ser.getSerializedDataLength(); //Get the serialized length
            return true;
        }

        bool StatusPubSubType::deserialize(SerializedPayload_t* payload, void* data) {
            Status* p_type = (Status*) data; 	//Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer((char*)payload->data, payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> StatusPubSubType::getSerializedSizeProvider(void* data) {
            return [data]() -> uint32_t
            {
                return (uint32_t)type::getCdrSerializedSize(*static_cast<Status*>(data)) + 4 /*encapsulation*/;
            };
        }

        void* StatusPubSubType::createData() {
            return (void*)new Status();
        }

        void StatusPubSubType::deleteData(void* data) {
            delete((Status*)data);
        }

        bool StatusPubSubType::getKey(void *data, InstanceHandle_t* handle) {
            if(!m_isGetKeyDefined)
                return false;
            Status* p_type = (Status*) data;
            eprosima::fastcdr::FastBuffer fastbuffer((char*)m_keyBuffer,Status::getKeyMaxCdrSerializedSize()); 	// Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS); 	// Object that serializes the data.
            p_type->serializeKey(ser);
            if(Status::getKeyMaxCdrSerializedSize()>16)	{
                m_md5.init();
                m_md5.update(m_keyBuffer,(unsigned int)ser.getSerializedDataLength());
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)    	{
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Capability

} //End of namespace AMM
