// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file AMMPubSubTypes.cpp
 * This header file contains the implementation of the serialization functions.
 *
 * This file was generated by the tool fastcdrgen.
 */


#include <fastcdr/FastBuffer.h>
#include <fastcdr/Cdr.h>

#include "AMMPubSubTypes.h"

using namespace eprosima::fastrtps;
using namespace eprosima::fastrtps::rtps;

namespace AMM
{
    FMA_LocationPubSubType::FMA_LocationPubSubType()
    {
        setName("AMM::FMA_Location");
        m_typeSize = static_cast<uint32_t>(FMA_Location::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
        m_isGetKeyDefined = FMA_Location::isKeyDefined();
        size_t keyLength = FMA_Location::getKeyMaxCdrSerializedSize()>16 ? FMA_Location::getKeyMaxCdrSerializedSize() : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    FMA_LocationPubSubType::~FMA_LocationPubSubType()
    {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool FMA_LocationPubSubType::serialize(void *data, SerializedPayload_t *payload)
    {
        FMA_Location *p_type = static_cast<FMA_Location*>(data);
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
        return true;
    }

    bool FMA_LocationPubSubType::deserialize(SerializedPayload_t* payload, void* data)
    {
        FMA_Location* p_type = static_cast<FMA_Location*>(data); //Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> FMA_LocationPubSubType::getSerializedSizeProvider(void* data)
    {
        return [data]() -> uint32_t
        {
            return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<FMA_Location*>(data))) + 4 /*encapsulation*/;
        };
    }

    void* FMA_LocationPubSubType::createData()
    {
        return reinterpret_cast<void*>(new FMA_Location());
    }

    void FMA_LocationPubSubType::deleteData(void* data)
    {
        delete(reinterpret_cast<FMA_Location*>(data));
    }

    bool FMA_LocationPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
    {
        if(!m_isGetKeyDefined)
            return false;
        FMA_Location* p_type = static_cast<FMA_Location*>(data);
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),FMA_Location::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
        p_type->serializeKey(ser);
        if(force_md5 || FMA_Location::getKeyMaxCdrSerializedSize()>16)    {
            m_md5.init();
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)        {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)        {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    UUIDPubSubType::UUIDPubSubType()
    {
        setName("AMM::UUID");
        m_typeSize = static_cast<uint32_t>(UUID::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
        m_isGetKeyDefined = UUID::isKeyDefined();
        size_t keyLength = UUID::getKeyMaxCdrSerializedSize()>16 ? UUID::getKeyMaxCdrSerializedSize() : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    UUIDPubSubType::~UUIDPubSubType()
    {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool UUIDPubSubType::serialize(void *data, SerializedPayload_t *payload)
    {
        UUID *p_type = static_cast<UUID*>(data);
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
        return true;
    }

    bool UUIDPubSubType::deserialize(SerializedPayload_t* payload, void* data)
    {
        UUID* p_type = static_cast<UUID*>(data); //Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> UUIDPubSubType::getSerializedSizeProvider(void* data)
    {
        return [data]() -> uint32_t
        {
            return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<UUID*>(data))) + 4 /*encapsulation*/;
        };
    }

    void* UUIDPubSubType::createData()
    {
        return reinterpret_cast<void*>(new UUID());
    }

    void UUIDPubSubType::deleteData(void* data)
    {
        delete(reinterpret_cast<UUID*>(data));
    }

    bool UUIDPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
    {
        if(!m_isGetKeyDefined)
            return false;
        UUID* p_type = static_cast<UUID*>(data);
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),UUID::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
        p_type->serializeKey(ser);
        if(force_md5 || UUID::getKeyMaxCdrSerializedSize()>16)    {
            m_md5.init();
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)        {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)        {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    namespace Event
    {
        FragmentPubSubType::FragmentPubSubType()
        {
            setName("AMM::Event::Fragment");
            m_typeSize = static_cast<uint32_t>(Fragment::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = Fragment::isKeyDefined();
            size_t keyLength = Fragment::getKeyMaxCdrSerializedSize()>16 ? Fragment::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        FragmentPubSubType::~FragmentPubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool FragmentPubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            Fragment *p_type = static_cast<Fragment*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool FragmentPubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            Fragment* p_type = static_cast<Fragment*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> FragmentPubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Fragment*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* FragmentPubSubType::createData()
        {
            return reinterpret_cast<void*>(new Fragment());
        }

        void FragmentPubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<Fragment*>(data));
        }

        bool FragmentPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            Fragment* p_type = static_cast<Fragment*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Fragment::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || Fragment::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        FragmentAmendmentRequestPubSubType::FragmentAmendmentRequestPubSubType()
        {
            setName("AMM::Event::FragmentAmendmentRequest");
            m_typeSize = static_cast<uint32_t>(FragmentAmendmentRequest::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = FragmentAmendmentRequest::isKeyDefined();
            size_t keyLength = FragmentAmendmentRequest::getKeyMaxCdrSerializedSize()>16 ? FragmentAmendmentRequest::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        FragmentAmendmentRequestPubSubType::~FragmentAmendmentRequestPubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool FragmentAmendmentRequestPubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            FragmentAmendmentRequest *p_type = static_cast<FragmentAmendmentRequest*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool FragmentAmendmentRequestPubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            FragmentAmendmentRequest* p_type = static_cast<FragmentAmendmentRequest*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> FragmentAmendmentRequestPubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<FragmentAmendmentRequest*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* FragmentAmendmentRequestPubSubType::createData()
        {
            return reinterpret_cast<void*>(new FragmentAmendmentRequest());
        }

        void FragmentAmendmentRequestPubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<FragmentAmendmentRequest*>(data));
        }

        bool FragmentAmendmentRequestPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            FragmentAmendmentRequest* p_type = static_cast<FragmentAmendmentRequest*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),FragmentAmendmentRequest::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || FragmentAmendmentRequest::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        RecordPubSubType::RecordPubSubType()
        {
            setName("AMM::Event::Record");
            m_typeSize = static_cast<uint32_t>(Record::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = Record::isKeyDefined();
            size_t keyLength = Record::getKeyMaxCdrSerializedSize()>16 ? Record::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        RecordPubSubType::~RecordPubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool RecordPubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            Record *p_type = static_cast<Record*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool RecordPubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            Record* p_type = static_cast<Record*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> RecordPubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Record*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* RecordPubSubType::createData()
        {
            return reinterpret_cast<void*>(new Record());
        }

        void RecordPubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<Record*>(data));
        }

        bool RecordPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            Record* p_type = static_cast<Record*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Record::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || Record::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Event
    namespace Environment
    {
        SettingsPubSubType::SettingsPubSubType()
        {
            setName("AMM::Environment::Settings");
            m_typeSize = static_cast<uint32_t>(Settings::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = Settings::isKeyDefined();
            size_t keyLength = Settings::getKeyMaxCdrSerializedSize()>16 ? Settings::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        SettingsPubSubType::~SettingsPubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool SettingsPubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            Settings *p_type = static_cast<Settings*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool SettingsPubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            Settings* p_type = static_cast<Settings*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> SettingsPubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Settings*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* SettingsPubSubType::createData()
        {
            return reinterpret_cast<void*>(new Settings());
        }

        void SettingsPubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<Settings*>(data));
        }

        bool SettingsPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            Settings* p_type = static_cast<Settings*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Settings::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || Settings::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Environment
    namespace Simulation
    {
        TickPubSubType::TickPubSubType()
        {
            setName("AMM::Simulation::Tick");
            m_typeSize = static_cast<uint32_t>(Tick::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = Tick::isKeyDefined();
            size_t keyLength = Tick::getKeyMaxCdrSerializedSize()>16 ? Tick::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        TickPubSubType::~TickPubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool TickPubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            Tick *p_type = static_cast<Tick*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool TickPubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            Tick* p_type = static_cast<Tick*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> TickPubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Tick*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* TickPubSubType::createData()
        {
            return reinterpret_cast<void*>(new Tick());
        }

        void TickPubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<Tick*>(data));
        }

        bool TickPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            Tick* p_type = static_cast<Tick*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Tick::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || Tick::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Simulation
    InstrumentDataPubSubType::InstrumentDataPubSubType()
    {
        setName("AMM::InstrumentData");
        m_typeSize = static_cast<uint32_t>(InstrumentData::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
        m_isGetKeyDefined = InstrumentData::isKeyDefined();
        size_t keyLength = InstrumentData::getKeyMaxCdrSerializedSize()>16 ? InstrumentData::getKeyMaxCdrSerializedSize() : 16;
        m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
        memset(m_keyBuffer, 0, keyLength);
    }

    InstrumentDataPubSubType::~InstrumentDataPubSubType()
    {
        if(m_keyBuffer!=nullptr)
            free(m_keyBuffer);
    }

    bool InstrumentDataPubSubType::serialize(void *data, SerializedPayload_t *payload)
    {
        InstrumentData *p_type = static_cast<InstrumentData*>(data);
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
        payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
        // Serialize encapsulation
        ser.serialize_encapsulation();

        try
        {
            p_type->serialize(ser); // Serialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
        return true;
    }

    bool InstrumentDataPubSubType::deserialize(SerializedPayload_t* payload, void* data)
    {
        InstrumentData* p_type = static_cast<InstrumentData*>(data); //Convert DATA to pointer of your type
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
        // Deserialize encapsulation.
        deser.read_encapsulation();
        payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

        try
        {
            p_type->deserialize(deser); //Deserialize the object:
        }
        catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
        {
            return false;
        }

        return true;
    }

    std::function<uint32_t()> InstrumentDataPubSubType::getSerializedSizeProvider(void* data)
    {
        return [data]() -> uint32_t
        {
            return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<InstrumentData*>(data))) + 4 /*encapsulation*/;
        };
    }

    void* InstrumentDataPubSubType::createData()
    {
        return reinterpret_cast<void*>(new InstrumentData());
    }

    void InstrumentDataPubSubType::deleteData(void* data)
    {
        delete(reinterpret_cast<InstrumentData*>(data));
    }

    bool InstrumentDataPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
    {
        if(!m_isGetKeyDefined)
            return false;
        InstrumentData* p_type = static_cast<InstrumentData*>(data);
        eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),InstrumentData::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
        eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
        p_type->serializeKey(ser);
        if(force_md5 || InstrumentData::getKeyMaxCdrSerializedSize()>16)    {
            m_md5.init();
            m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
            m_md5.finalize();
            for(uint8_t i = 0;i<16;++i)        {
                handle->value[i] = m_md5.digest[i];
            }
        }
        else    {
            for(uint8_t i = 0;i<16;++i)        {
                handle->value[i] = m_keyBuffer[i];
            }
        }
        return true;
    }

    namespace Physiology
    {


        CommandPubSubType::CommandPubSubType()
        {
            setName("AMM::Physiology::Command");
            m_typeSize = static_cast<uint32_t>(Command::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = Command::isKeyDefined();
            size_t keyLength = Command::getKeyMaxCdrSerializedSize()>16 ? Command::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        CommandPubSubType::~CommandPubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool CommandPubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            Command *p_type = static_cast<Command*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool CommandPubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            Command* p_type = static_cast<Command*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> CommandPubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Command*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* CommandPubSubType::createData()
        {
            return reinterpret_cast<void*>(new Command());
        }

        void CommandPubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<Command*>(data));
        }

        bool CommandPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            Command* p_type = static_cast<Command*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Command::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || Command::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        namespace PainStimulus
        {
            DataPubSubType::DataPubSubType()
            {
                setName("AMM::Physiology::PainStimulus::Data");
                m_typeSize = static_cast<uint32_t>(Data::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                m_isGetKeyDefined = Data::isKeyDefined();
                size_t keyLength = Data::getKeyMaxCdrSerializedSize()>16 ? Data::getKeyMaxCdrSerializedSize() : 16;
                m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                memset(m_keyBuffer, 0, keyLength);
            }

            DataPubSubType::~DataPubSubType()
            {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool DataPubSubType::serialize(void *data, SerializedPayload_t *payload)
            {
                Data *p_type = static_cast<Data*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                return true;
            }

            bool DataPubSubType::deserialize(SerializedPayload_t* payload, void* data)
            {
                Data* p_type = static_cast<Data*>(data); //Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> DataPubSubType::getSerializedSizeProvider(void* data)
            {
                return [data]() -> uint32_t
                {
                    return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Data*>(data))) + 4 /*encapsulation*/;
                };
            }

            void* DataPubSubType::createData()
            {
                return reinterpret_cast<void*>(new Data());
            }

            void DataPubSubType::deleteData(void* data)
            {
                delete(reinterpret_cast<Data*>(data));
            }

            bool DataPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
            {
                if(!m_isGetKeyDefined)
                    return false;
                Data* p_type = static_cast<Data*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Data::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                p_type->serializeKey(ser);
                if(force_md5 || Data::getKeyMaxCdrSerializedSize()>16)    {
                    m_md5.init();
                    m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }


        } //End of namespace PainStimulus
        namespace Sepsis
        {
            DataPubSubType::DataPubSubType()
            {
                setName("AMM::Physiology::Sepsis::Data");
                m_typeSize = static_cast<uint32_t>(Data::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                m_isGetKeyDefined = Data::isKeyDefined();
                size_t keyLength = Data::getKeyMaxCdrSerializedSize()>16 ? Data::getKeyMaxCdrSerializedSize() : 16;
                m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                memset(m_keyBuffer, 0, keyLength);
            }

            DataPubSubType::~DataPubSubType()
            {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool DataPubSubType::serialize(void *data, SerializedPayload_t *payload)
            {
                Data *p_type = static_cast<Data*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                return true;
            }

            bool DataPubSubType::deserialize(SerializedPayload_t* payload, void* data)
            {
                Data* p_type = static_cast<Data*>(data); //Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> DataPubSubType::getSerializedSizeProvider(void* data)
            {
                return [data]() -> uint32_t
                {
                    return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Data*>(data))) + 4 /*encapsulation*/;
                };
            }

            void* DataPubSubType::createData()
            {
                return reinterpret_cast<void*>(new Data());
            }

            void DataPubSubType::deleteData(void* data)
            {
                delete(reinterpret_cast<Data*>(data));
            }

            bool DataPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
            {
                if(!m_isGetKeyDefined)
                    return false;
                Data* p_type = static_cast<Data*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Data::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                p_type->serializeKey(ser);
                if(force_md5 || Data::getKeyMaxCdrSerializedSize()>16)    {
                    m_md5.init();
                    m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }


        } //End of namespace Sepsis
        ModificationPubSubType::ModificationPubSubType()
        {
            setName("AMM::Physiology::Modification");
            m_typeSize = static_cast<uint32_t>(Modification::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = Modification::isKeyDefined();
            size_t keyLength = Modification::getKeyMaxCdrSerializedSize()>16 ? Modification::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        ModificationPubSubType::~ModificationPubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool ModificationPubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            Modification *p_type = static_cast<Modification*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool ModificationPubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            Modification* p_type = static_cast<Modification*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> ModificationPubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Modification*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* ModificationPubSubType::createData()
        {
            return reinterpret_cast<void*>(new Modification());
        }

        void ModificationPubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<Modification*>(data));
        }

        bool ModificationPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            Modification* p_type = static_cast<Modification*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Modification::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || Modification::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        NodePubSubType::NodePubSubType()
        {
            setName("AMM::Physiology::Node");
            m_typeSize = static_cast<uint32_t>(Node::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = Node::isKeyDefined();
            size_t keyLength = Node::getKeyMaxCdrSerializedSize()>16 ? Node::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        NodePubSubType::~NodePubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool NodePubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            Node *p_type = static_cast<Node*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool NodePubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            Node* p_type = static_cast<Node*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> NodePubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Node*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* NodePubSubType::createData()
        {
            return reinterpret_cast<void*>(new Node());
        }

        void NodePubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<Node*>(data));
        }

        bool NodePubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            Node* p_type = static_cast<Node*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Node::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || Node::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        HighFrequencyNodePubSubType::HighFrequencyNodePubSubType()
        {
            setName("AMM::Physiology::HighFrequencyNode");
            m_typeSize = static_cast<uint32_t>(HighFrequencyNode::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = HighFrequencyNode::isKeyDefined();
            size_t keyLength = HighFrequencyNode::getKeyMaxCdrSerializedSize()>16 ? HighFrequencyNode::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        HighFrequencyNodePubSubType::~HighFrequencyNodePubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool HighFrequencyNodePubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            HighFrequencyNode *p_type = static_cast<HighFrequencyNode*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool HighFrequencyNodePubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            HighFrequencyNode* p_type = static_cast<HighFrequencyNode*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> HighFrequencyNodePubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<HighFrequencyNode*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* HighFrequencyNodePubSubType::createData()
        {
            return reinterpret_cast<void*>(new HighFrequencyNode());
        }

        void HighFrequencyNodePubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<HighFrequencyNode*>(data));
        }

        bool HighFrequencyNodePubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            HighFrequencyNode* p_type = static_cast<HighFrequencyNode*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),HighFrequencyNode::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || HighFrequencyNode::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Physiology
    namespace Render
    {
        ModificationPubSubType::ModificationPubSubType()
        {
            setName("AMM::Render::Modification");
            m_typeSize = static_cast<uint32_t>(Modification::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = Modification::isKeyDefined();
            size_t keyLength = Modification::getKeyMaxCdrSerializedSize()>16 ? Modification::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        ModificationPubSubType::~ModificationPubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool ModificationPubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            Modification *p_type = static_cast<Modification*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool ModificationPubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            Modification* p_type = static_cast<Modification*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> ModificationPubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Modification*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* ModificationPubSubType::createData()
        {
            return reinterpret_cast<void*>(new Modification());
        }

        void ModificationPubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<Modification*>(data));
        }

        bool ModificationPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            Modification* p_type = static_cast<Modification*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Modification::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || Modification::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Render
    namespace PatientAction
    {
        namespace BioGears
        {
            CommandPubSubType::CommandPubSubType()
            {
                setName("AMM::PatientAction::BioGears::Command");
                m_typeSize = static_cast<uint32_t>(Command::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                m_isGetKeyDefined = Command::isKeyDefined();
                size_t keyLength = Command::getKeyMaxCdrSerializedSize()>16 ? Command::getKeyMaxCdrSerializedSize() : 16;
                m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                memset(m_keyBuffer, 0, keyLength);
            }

            CommandPubSubType::~CommandPubSubType()
            {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool CommandPubSubType::serialize(void *data, SerializedPayload_t *payload)
            {
                Command *p_type = static_cast<Command*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                return true;
            }

            bool CommandPubSubType::deserialize(SerializedPayload_t* payload, void* data)
            {
                Command* p_type = static_cast<Command*>(data); //Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> CommandPubSubType::getSerializedSizeProvider(void* data)
            {
                return [data]() -> uint32_t
                {
                    return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Command*>(data))) + 4 /*encapsulation*/;
                };
            }

            void* CommandPubSubType::createData()
            {
                return reinterpret_cast<void*>(new Command());
            }

            void CommandPubSubType::deleteData(void* data)
            {
                delete(reinterpret_cast<Command*>(data));
            }

            bool CommandPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
            {
                if(!m_isGetKeyDefined)
                    return false;
                Command* p_type = static_cast<Command*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Command::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                p_type->serializeKey(ser);
                if(force_md5 || Command::getKeyMaxCdrSerializedSize()>16)    {
                    m_md5.init();
                    m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }


        } //End of namespace BioGears

    } //End of namespace PatientAction
    namespace Performance
    {
        xAPIModifierPubSubType::xAPIModifierPubSubType()
        {
            setName("AMM::Performance::xAPIModifier");
            m_typeSize = static_cast<uint32_t>(xAPIModifier::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = xAPIModifier::isKeyDefined();
            size_t keyLength = xAPIModifier::getKeyMaxCdrSerializedSize()>16 ? xAPIModifier::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        xAPIModifierPubSubType::~xAPIModifierPubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool xAPIModifierPubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            xAPIModifier *p_type = static_cast<xAPIModifier*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool xAPIModifierPubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            xAPIModifier* p_type = static_cast<xAPIModifier*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> xAPIModifierPubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<xAPIModifier*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* xAPIModifierPubSubType::createData()
        {
            return reinterpret_cast<void*>(new xAPIModifier());
        }

        void xAPIModifierPubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<xAPIModifier*>(data));
        }

        bool xAPIModifierPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            xAPIModifier* p_type = static_cast<xAPIModifier*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),xAPIModifier::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || xAPIModifier::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


        StatementPubSubType::StatementPubSubType()
        {
            setName("AMM::Performance::Statement");
            m_typeSize = static_cast<uint32_t>(Statement::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = Statement::isKeyDefined();
            size_t keyLength = Statement::getKeyMaxCdrSerializedSize()>16 ? Statement::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        StatementPubSubType::~StatementPubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool StatementPubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            Statement *p_type = static_cast<Statement*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool StatementPubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            Statement* p_type = static_cast<Statement*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> StatementPubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Statement*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* StatementPubSubType::createData()
        {
            return reinterpret_cast<void*>(new Statement());
        }

        void StatementPubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<Statement*>(data));
        }

        bool StatementPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            Statement* p_type = static_cast<Statement*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Statement::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || Statement::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        AssessmentPubSubType::AssessmentPubSubType()
        {
            setName("AMM::Performance::Assessment");
            m_typeSize = static_cast<uint32_t>(Assessment::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = Assessment::isKeyDefined();
            size_t keyLength = Assessment::getKeyMaxCdrSerializedSize()>16 ? Assessment::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        AssessmentPubSubType::~AssessmentPubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool AssessmentPubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            Assessment *p_type = static_cast<Assessment*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool AssessmentPubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            Assessment* p_type = static_cast<Assessment*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> AssessmentPubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Assessment*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* AssessmentPubSubType::createData()
        {
            return reinterpret_cast<void*>(new Assessment());
        }

        void AssessmentPubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<Assessment*>(data));
        }

        bool AssessmentPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            Assessment* p_type = static_cast<Assessment*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Assessment::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || Assessment::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Performance
    namespace Resource
    {
        namespace Requirement
        {
            PowerPubSubType::PowerPubSubType()
            {
                setName("AMM::Resource::Requirement::Power");
                m_typeSize = static_cast<uint32_t>(Power::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                m_isGetKeyDefined = Power::isKeyDefined();
                size_t keyLength = Power::getKeyMaxCdrSerializedSize()>16 ? Power::getKeyMaxCdrSerializedSize() : 16;
                m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                memset(m_keyBuffer, 0, keyLength);
            }

            PowerPubSubType::~PowerPubSubType()
            {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool PowerPubSubType::serialize(void *data, SerializedPayload_t *payload)
            {
                Power *p_type = static_cast<Power*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                return true;
            }

            bool PowerPubSubType::deserialize(SerializedPayload_t* payload, void* data)
            {
                Power* p_type = static_cast<Power*>(data); //Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> PowerPubSubType::getSerializedSizeProvider(void* data)
            {
                return [data]() -> uint32_t
                {
                    return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Power*>(data))) + 4 /*encapsulation*/;
                };
            }

            void* PowerPubSubType::createData()
            {
                return reinterpret_cast<void*>(new Power());
            }

            void PowerPubSubType::deleteData(void* data)
            {
                delete(reinterpret_cast<Power*>(data));
            }

            bool PowerPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
            {
                if(!m_isGetKeyDefined)
                    return false;
                Power* p_type = static_cast<Power*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Power::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                p_type->serializeKey(ser);
                if(force_md5 || Power::getKeyMaxCdrSerializedSize()>16)    {
                    m_md5.init();
                    m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            BloodPubSubType::BloodPubSubType()
            {
                setName("AMM::Resource::Requirement::Blood");
                m_typeSize = static_cast<uint32_t>(Blood::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                m_isGetKeyDefined = Blood::isKeyDefined();
                size_t keyLength = Blood::getKeyMaxCdrSerializedSize()>16 ? Blood::getKeyMaxCdrSerializedSize() : 16;
                m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                memset(m_keyBuffer, 0, keyLength);
            }

            BloodPubSubType::~BloodPubSubType()
            {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool BloodPubSubType::serialize(void *data, SerializedPayload_t *payload)
            {
                Blood *p_type = static_cast<Blood*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                return true;
            }

            bool BloodPubSubType::deserialize(SerializedPayload_t* payload, void* data)
            {
                Blood* p_type = static_cast<Blood*>(data); //Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> BloodPubSubType::getSerializedSizeProvider(void* data)
            {
                return [data]() -> uint32_t
                {
                    return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Blood*>(data))) + 4 /*encapsulation*/;
                };
            }

            void* BloodPubSubType::createData()
            {
                return reinterpret_cast<void*>(new Blood());
            }

            void BloodPubSubType::deleteData(void* data)
            {
                delete(reinterpret_cast<Blood*>(data));
            }

            bool BloodPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
            {
                if(!m_isGetKeyDefined)
                    return false;
                Blood* p_type = static_cast<Blood*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Blood::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                p_type->serializeKey(ser);
                if(force_md5 || Blood::getKeyMaxCdrSerializedSize()>16)    {
                    m_md5.init();
                    m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            Clear_LiquidPubSubType::Clear_LiquidPubSubType()
            {
                setName("AMM::Resource::Requirement::Clear_Liquid");
                m_typeSize = static_cast<uint32_t>(Clear_Liquid::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                m_isGetKeyDefined = Clear_Liquid::isKeyDefined();
                size_t keyLength = Clear_Liquid::getKeyMaxCdrSerializedSize()>16 ? Clear_Liquid::getKeyMaxCdrSerializedSize() : 16;
                m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                memset(m_keyBuffer, 0, keyLength);
            }

            Clear_LiquidPubSubType::~Clear_LiquidPubSubType()
            {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool Clear_LiquidPubSubType::serialize(void *data, SerializedPayload_t *payload)
            {
                Clear_Liquid *p_type = static_cast<Clear_Liquid*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                return true;
            }

            bool Clear_LiquidPubSubType::deserialize(SerializedPayload_t* payload, void* data)
            {
                Clear_Liquid* p_type = static_cast<Clear_Liquid*>(data); //Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> Clear_LiquidPubSubType::getSerializedSizeProvider(void* data)
            {
                return [data]() -> uint32_t
                {
                    return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Clear_Liquid*>(data))) + 4 /*encapsulation*/;
                };
            }

            void* Clear_LiquidPubSubType::createData()
            {
                return reinterpret_cast<void*>(new Clear_Liquid());
            }

            void Clear_LiquidPubSubType::deleteData(void* data)
            {
                delete(reinterpret_cast<Clear_Liquid*>(data));
            }

            bool Clear_LiquidPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
            {
                if(!m_isGetKeyDefined)
                    return false;
                Clear_Liquid* p_type = static_cast<Clear_Liquid*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Clear_Liquid::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                p_type->serializeKey(ser);
                if(force_md5 || Clear_Liquid::getKeyMaxCdrSerializedSize()>16)    {
                    m_md5.init();
                    m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            AirPubSubType::AirPubSubType()
            {
                setName("AMM::Resource::Requirement::Air");
                m_typeSize = static_cast<uint32_t>(Air::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                m_isGetKeyDefined = Air::isKeyDefined();
                size_t keyLength = Air::getKeyMaxCdrSerializedSize()>16 ? Air::getKeyMaxCdrSerializedSize() : 16;
                m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                memset(m_keyBuffer, 0, keyLength);
            }

            AirPubSubType::~AirPubSubType()
            {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool AirPubSubType::serialize(void *data, SerializedPayload_t *payload)
            {
                Air *p_type = static_cast<Air*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                return true;
            }

            bool AirPubSubType::deserialize(SerializedPayload_t* payload, void* data)
            {
                Air* p_type = static_cast<Air*>(data); //Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> AirPubSubType::getSerializedSizeProvider(void* data)
            {
                return [data]() -> uint32_t
                {
                    return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Air*>(data))) + 4 /*encapsulation*/;
                };
            }

            void* AirPubSubType::createData()
            {
                return reinterpret_cast<void*>(new Air());
            }

            void AirPubSubType::deleteData(void* data)
            {
                delete(reinterpret_cast<Air*>(data));
            }

            bool AirPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
            {
                if(!m_isGetKeyDefined)
                    return false;
                Air* p_type = static_cast<Air*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Air::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                p_type->serializeKey(ser);
                if(force_md5 || Air::getKeyMaxCdrSerializedSize()>16)    {
                    m_md5.init();
                    m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            Cleaning_SolutionPubSubType::Cleaning_SolutionPubSubType()
            {
                setName("AMM::Resource::Requirement::Cleaning_Solution");
                m_typeSize = static_cast<uint32_t>(Cleaning_Solution::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                m_isGetKeyDefined = Cleaning_Solution::isKeyDefined();
                size_t keyLength = Cleaning_Solution::getKeyMaxCdrSerializedSize()>16 ? Cleaning_Solution::getKeyMaxCdrSerializedSize() : 16;
                m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                memset(m_keyBuffer, 0, keyLength);
            }

            Cleaning_SolutionPubSubType::~Cleaning_SolutionPubSubType()
            {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool Cleaning_SolutionPubSubType::serialize(void *data, SerializedPayload_t *payload)
            {
                Cleaning_Solution *p_type = static_cast<Cleaning_Solution*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                return true;
            }

            bool Cleaning_SolutionPubSubType::deserialize(SerializedPayload_t* payload, void* data)
            {
                Cleaning_Solution* p_type = static_cast<Cleaning_Solution*>(data); //Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> Cleaning_SolutionPubSubType::getSerializedSizeProvider(void* data)
            {
                return [data]() -> uint32_t
                {
                    return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Cleaning_Solution*>(data))) + 4 /*encapsulation*/;
                };
            }

            void* Cleaning_SolutionPubSubType::createData()
            {
                return reinterpret_cast<void*>(new Cleaning_Solution());
            }

            void Cleaning_SolutionPubSubType::deleteData(void* data)
            {
                delete(reinterpret_cast<Cleaning_Solution*>(data));
            }

            bool Cleaning_SolutionPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
            {
                if(!m_isGetKeyDefined)
                    return false;
                Cleaning_Solution* p_type = static_cast<Cleaning_Solution*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Cleaning_Solution::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                p_type->serializeKey(ser);
                if(force_md5 || Cleaning_Solution::getKeyMaxCdrSerializedSize()>16)    {
                    m_md5.init();
                    m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }


        } //End of namespace Requirement
        namespace Supply
        {
            PowerPubSubType::PowerPubSubType()
            {
                setName("AMM::Resource::Supply::Power");
                m_typeSize = static_cast<uint32_t>(Power::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                m_isGetKeyDefined = Power::isKeyDefined();
                size_t keyLength = Power::getKeyMaxCdrSerializedSize()>16 ? Power::getKeyMaxCdrSerializedSize() : 16;
                m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                memset(m_keyBuffer, 0, keyLength);
            }

            PowerPubSubType::~PowerPubSubType()
            {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool PowerPubSubType::serialize(void *data, SerializedPayload_t *payload)
            {
                Power *p_type = static_cast<Power*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                return true;
            }

            bool PowerPubSubType::deserialize(SerializedPayload_t* payload, void* data)
            {
                Power* p_type = static_cast<Power*>(data); //Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> PowerPubSubType::getSerializedSizeProvider(void* data)
            {
                return [data]() -> uint32_t
                {
                    return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Power*>(data))) + 4 /*encapsulation*/;
                };
            }

            void* PowerPubSubType::createData()
            {
                return reinterpret_cast<void*>(new Power());
            }

            void PowerPubSubType::deleteData(void* data)
            {
                delete(reinterpret_cast<Power*>(data));
            }

            bool PowerPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
            {
                if(!m_isGetKeyDefined)
                    return false;
                Power* p_type = static_cast<Power*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Power::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                p_type->serializeKey(ser);
                if(force_md5 || Power::getKeyMaxCdrSerializedSize()>16)    {
                    m_md5.init();
                    m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            BloodPubSubType::BloodPubSubType()
            {
                setName("AMM::Resource::Supply::Blood");
                m_typeSize = static_cast<uint32_t>(Blood::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                m_isGetKeyDefined = Blood::isKeyDefined();
                size_t keyLength = Blood::getKeyMaxCdrSerializedSize()>16 ? Blood::getKeyMaxCdrSerializedSize() : 16;
                m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                memset(m_keyBuffer, 0, keyLength);
            }

            BloodPubSubType::~BloodPubSubType()
            {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool BloodPubSubType::serialize(void *data, SerializedPayload_t *payload)
            {
                Blood *p_type = static_cast<Blood*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                return true;
            }

            bool BloodPubSubType::deserialize(SerializedPayload_t* payload, void* data)
            {
                Blood* p_type = static_cast<Blood*>(data); //Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> BloodPubSubType::getSerializedSizeProvider(void* data)
            {
                return [data]() -> uint32_t
                {
                    return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Blood*>(data))) + 4 /*encapsulation*/;
                };
            }

            void* BloodPubSubType::createData()
            {
                return reinterpret_cast<void*>(new Blood());
            }

            void BloodPubSubType::deleteData(void* data)
            {
                delete(reinterpret_cast<Blood*>(data));
            }

            bool BloodPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
            {
                if(!m_isGetKeyDefined)
                    return false;
                Blood* p_type = static_cast<Blood*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Blood::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                p_type->serializeKey(ser);
                if(force_md5 || Blood::getKeyMaxCdrSerializedSize()>16)    {
                    m_md5.init();
                    m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            Clear_LiquidPubSubType::Clear_LiquidPubSubType()
            {
                setName("AMM::Resource::Supply::Clear_Liquid");
                m_typeSize = static_cast<uint32_t>(Clear_Liquid::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                m_isGetKeyDefined = Clear_Liquid::isKeyDefined();
                size_t keyLength = Clear_Liquid::getKeyMaxCdrSerializedSize()>16 ? Clear_Liquid::getKeyMaxCdrSerializedSize() : 16;
                m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                memset(m_keyBuffer, 0, keyLength);
            }

            Clear_LiquidPubSubType::~Clear_LiquidPubSubType()
            {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool Clear_LiquidPubSubType::serialize(void *data, SerializedPayload_t *payload)
            {
                Clear_Liquid *p_type = static_cast<Clear_Liquid*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                return true;
            }

            bool Clear_LiquidPubSubType::deserialize(SerializedPayload_t* payload, void* data)
            {
                Clear_Liquid* p_type = static_cast<Clear_Liquid*>(data); //Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> Clear_LiquidPubSubType::getSerializedSizeProvider(void* data)
            {
                return [data]() -> uint32_t
                {
                    return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Clear_Liquid*>(data))) + 4 /*encapsulation*/;
                };
            }

            void* Clear_LiquidPubSubType::createData()
            {
                return reinterpret_cast<void*>(new Clear_Liquid());
            }

            void Clear_LiquidPubSubType::deleteData(void* data)
            {
                delete(reinterpret_cast<Clear_Liquid*>(data));
            }

            bool Clear_LiquidPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
            {
                if(!m_isGetKeyDefined)
                    return false;
                Clear_Liquid* p_type = static_cast<Clear_Liquid*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Clear_Liquid::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                p_type->serializeKey(ser);
                if(force_md5 || Clear_Liquid::getKeyMaxCdrSerializedSize()>16)    {
                    m_md5.init();
                    m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            AirPubSubType::AirPubSubType()
            {
                setName("AMM::Resource::Supply::Air");
                m_typeSize = static_cast<uint32_t>(Air::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                m_isGetKeyDefined = Air::isKeyDefined();
                size_t keyLength = Air::getKeyMaxCdrSerializedSize()>16 ? Air::getKeyMaxCdrSerializedSize() : 16;
                m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                memset(m_keyBuffer, 0, keyLength);
            }

            AirPubSubType::~AirPubSubType()
            {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool AirPubSubType::serialize(void *data, SerializedPayload_t *payload)
            {
                Air *p_type = static_cast<Air*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                return true;
            }

            bool AirPubSubType::deserialize(SerializedPayload_t* payload, void* data)
            {
                Air* p_type = static_cast<Air*>(data); //Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> AirPubSubType::getSerializedSizeProvider(void* data)
            {
                return [data]() -> uint32_t
                {
                    return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Air*>(data))) + 4 /*encapsulation*/;
                };
            }

            void* AirPubSubType::createData()
            {
                return reinterpret_cast<void*>(new Air());
            }

            void AirPubSubType::deleteData(void* data)
            {
                delete(reinterpret_cast<Air*>(data));
            }

            bool AirPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
            {
                if(!m_isGetKeyDefined)
                    return false;
                Air* p_type = static_cast<Air*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Air::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                p_type->serializeKey(ser);
                if(force_md5 || Air::getKeyMaxCdrSerializedSize()>16)    {
                    m_md5.init();
                    m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }

            Cleaning_SolutionPubSubType::Cleaning_SolutionPubSubType()
            {
                setName("AMM::Resource::Supply::Cleaning_Solution");
                m_typeSize = static_cast<uint32_t>(Cleaning_Solution::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                m_isGetKeyDefined = Cleaning_Solution::isKeyDefined();
                size_t keyLength = Cleaning_Solution::getKeyMaxCdrSerializedSize()>16 ? Cleaning_Solution::getKeyMaxCdrSerializedSize() : 16;
                m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                memset(m_keyBuffer, 0, keyLength);
            }

            Cleaning_SolutionPubSubType::~Cleaning_SolutionPubSubType()
            {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool Cleaning_SolutionPubSubType::serialize(void *data, SerializedPayload_t *payload)
            {
                Cleaning_Solution *p_type = static_cast<Cleaning_Solution*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                return true;
            }

            bool Cleaning_SolutionPubSubType::deserialize(SerializedPayload_t* payload, void* data)
            {
                Cleaning_Solution* p_type = static_cast<Cleaning_Solution*>(data); //Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> Cleaning_SolutionPubSubType::getSerializedSizeProvider(void* data)
            {
                return [data]() -> uint32_t
                {
                    return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Cleaning_Solution*>(data))) + 4 /*encapsulation*/;
                };
            }

            void* Cleaning_SolutionPubSubType::createData()
            {
                return reinterpret_cast<void*>(new Cleaning_Solution());
            }

            void Cleaning_SolutionPubSubType::deleteData(void* data)
            {
                delete(reinterpret_cast<Cleaning_Solution*>(data));
            }

            bool Cleaning_SolutionPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
            {
                if(!m_isGetKeyDefined)
                    return false;
                Cleaning_Solution* p_type = static_cast<Cleaning_Solution*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Cleaning_Solution::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                p_type->serializeKey(ser);
                if(force_md5 || Cleaning_Solution::getKeyMaxCdrSerializedSize()>16)    {
                    m_md5.init();
                    m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }


        } //End of namespace Supply

    } //End of namespace Resource
    namespace Capability
    {

        AMM_versionPubSubType::AMM_versionPubSubType()
        {
            setName("AMM::Capability::AMM_version");
            m_typeSize = static_cast<uint32_t>(AMM_version::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = AMM_version::isKeyDefined();
            size_t keyLength = AMM_version::getKeyMaxCdrSerializedSize()>16 ? AMM_version::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        AMM_versionPubSubType::~AMM_versionPubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool AMM_versionPubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            AMM_version *p_type = static_cast<AMM_version*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool AMM_versionPubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            AMM_version* p_type = static_cast<AMM_version*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> AMM_versionPubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<AMM_version*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* AMM_versionPubSubType::createData()
        {
            return reinterpret_cast<void*>(new AMM_version());
        }

        void AMM_versionPubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<AMM_version*>(data));
        }

        bool AMM_versionPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            AMM_version* p_type = static_cast<AMM_version*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),AMM_version::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || AMM_version::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        ConfigurationPubSubType::ConfigurationPubSubType()
        {
            setName("AMM::Capability::Configuration");
            m_typeSize = static_cast<uint32_t>(Configuration::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = Configuration::isKeyDefined();
            size_t keyLength = Configuration::getKeyMaxCdrSerializedSize()>16 ? Configuration::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        ConfigurationPubSubType::~ConfigurationPubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool ConfigurationPubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            Configuration *p_type = static_cast<Configuration*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool ConfigurationPubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            Configuration* p_type = static_cast<Configuration*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> ConfigurationPubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Configuration*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* ConfigurationPubSubType::createData()
        {
            return reinterpret_cast<void*>(new Configuration());
        }

        void ConfigurationPubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<Configuration*>(data));
        }

        bool ConfigurationPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            Configuration* p_type = static_cast<Configuration*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Configuration::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || Configuration::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        ScenarioPubSubType::ScenarioPubSubType()
        {
            setName("AMM::Capability::Scenario");
            m_typeSize = static_cast<uint32_t>(Scenario::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = Scenario::isKeyDefined();
            size_t keyLength = Scenario::getKeyMaxCdrSerializedSize()>16 ? Scenario::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        ScenarioPubSubType::~ScenarioPubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool ScenarioPubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            Scenario *p_type = static_cast<Scenario*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool ScenarioPubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            Scenario* p_type = static_cast<Scenario*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> ScenarioPubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Scenario*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* ScenarioPubSubType::createData()
        {
            return reinterpret_cast<void*>(new Scenario());
        }

        void ScenarioPubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<Scenario*>(data));
        }

        bool ScenarioPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            Scenario* p_type = static_cast<Scenario*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Scenario::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || Scenario::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }

        StatusPubSubType::StatusPubSubType()
        {
            setName("AMM::Capability::Status");
            m_typeSize = static_cast<uint32_t>(Status::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
            m_isGetKeyDefined = Status::isKeyDefined();
            size_t keyLength = Status::getKeyMaxCdrSerializedSize()>16 ? Status::getKeyMaxCdrSerializedSize() : 16;
            m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
            memset(m_keyBuffer, 0, keyLength);
        }

        StatusPubSubType::~StatusPubSubType()
        {
            if(m_keyBuffer!=nullptr)
                free(m_keyBuffer);
        }

        bool StatusPubSubType::serialize(void *data, SerializedPayload_t *payload)
        {
            Status *p_type = static_cast<Status*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
            payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
            // Serialize encapsulation
            ser.serialize_encapsulation();

            try
            {
                p_type->serialize(ser); // Serialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
            return true;
        }

        bool StatusPubSubType::deserialize(SerializedPayload_t* payload, void* data)
        {
            Status* p_type = static_cast<Status*>(data); //Convert DATA to pointer of your type
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                    eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
            // Deserialize encapsulation.
            deser.read_encapsulation();
            payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

            try
            {
                p_type->deserialize(deser); //Deserialize the object:
            }
            catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
            {
                return false;
            }

            return true;
        }

        std::function<uint32_t()> StatusPubSubType::getSerializedSizeProvider(void* data)
        {
            return [data]() -> uint32_t
            {
                return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Status*>(data))) + 4 /*encapsulation*/;
            };
        }

        void* StatusPubSubType::createData()
        {
            return reinterpret_cast<void*>(new Status());
        }

        void StatusPubSubType::deleteData(void* data)
        {
            delete(reinterpret_cast<Status*>(data));
        }

        bool StatusPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
        {
            if(!m_isGetKeyDefined)
                return false;
            Status* p_type = static_cast<Status*>(data);
            eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Status::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
            eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
            p_type->serializeKey(ser);
            if(force_md5 || Status::getKeyMaxCdrSerializedSize()>16)    {
                m_md5.init();
                m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                m_md5.finalize();
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_md5.digest[i];
                }
            }
            else    {
                for(uint8_t i = 0;i<16;++i)        {
                    handle->value[i] = m_keyBuffer[i];
                }
            }
            return true;
        }


    } //End of namespace Capability
    namespace Diagnostics
    {
        namespace Log
        {
            RecordPubSubType::RecordPubSubType()
            {
                setName("AMM::Diagnostics::Log::Record");
                m_typeSize = static_cast<uint32_t>(Record::getMaxCdrSerializedSize()) + 4 /*encapsulation*/;
                m_isGetKeyDefined = Record::isKeyDefined();
                size_t keyLength = Record::getKeyMaxCdrSerializedSize()>16 ? Record::getKeyMaxCdrSerializedSize() : 16;
                m_keyBuffer = reinterpret_cast<unsigned char*>(malloc(keyLength));
                memset(m_keyBuffer, 0, keyLength);
            }

            RecordPubSubType::~RecordPubSubType()
            {
                if(m_keyBuffer!=nullptr)
                    free(m_keyBuffer);
            }

            bool RecordPubSubType::serialize(void *data, SerializedPayload_t *payload)
            {
                Record *p_type = static_cast<Record*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->max_size); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that serializes the data.
                payload->encapsulation = ser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;
                // Serialize encapsulation
                ser.serialize_encapsulation();

                try
                {
                    p_type->serialize(ser); // Serialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                payload->length = static_cast<uint32_t>(ser.getSerializedDataLength()); //Get the serialized length
                return true;
            }

            bool RecordPubSubType::deserialize(SerializedPayload_t* payload, void* data)
            {
                Record* p_type = static_cast<Record*>(data); //Convert DATA to pointer of your type
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(payload->data), payload->length); // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr deser(fastbuffer, eprosima::fastcdr::Cdr::DEFAULT_ENDIAN,
                        eprosima::fastcdr::Cdr::DDS_CDR); // Object that deserializes the data.
                // Deserialize encapsulation.
                deser.read_encapsulation();
                payload->encapsulation = deser.endianness() == eprosima::fastcdr::Cdr::BIG_ENDIANNESS ? CDR_BE : CDR_LE;

                try
                {
                    p_type->deserialize(deser); //Deserialize the object:
                }
                catch(eprosima::fastcdr::exception::NotEnoughMemoryException& /*exception*/)
                {
                    return false;
                }

                return true;
            }

            std::function<uint32_t()> RecordPubSubType::getSerializedSizeProvider(void* data)
            {
                return [data]() -> uint32_t
                {
                    return static_cast<uint32_t>(type::getCdrSerializedSize(*static_cast<Record*>(data))) + 4 /*encapsulation*/;
                };
            }

            void* RecordPubSubType::createData()
            {
                return reinterpret_cast<void*>(new Record());
            }

            void RecordPubSubType::deleteData(void* data)
            {
                delete(reinterpret_cast<Record*>(data));
            }

            bool RecordPubSubType::getKey(void *data, InstanceHandle_t* handle, bool force_md5)
            {
                if(!m_isGetKeyDefined)
                    return false;
                Record* p_type = static_cast<Record*>(data);
                eprosima::fastcdr::FastBuffer fastbuffer(reinterpret_cast<char*>(m_keyBuffer),Record::getKeyMaxCdrSerializedSize());     // Object that manages the raw buffer.
                eprosima::fastcdr::Cdr ser(fastbuffer, eprosima::fastcdr::Cdr::BIG_ENDIANNESS);     // Object that serializes the data.
                p_type->serializeKey(ser);
                if(force_md5 || Record::getKeyMaxCdrSerializedSize()>16)    {
                    m_md5.init();
                    m_md5.update(m_keyBuffer, static_cast<unsigned int>(ser.getSerializedDataLength()));
                    m_md5.finalize();
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_md5.digest[i];
                    }
                }
                else    {
                    for(uint8_t i = 0;i<16;++i)        {
                        handle->value[i] = m_keyBuffer[i];
                    }
                }
                return true;
            }


        } //End of namespace Log

    } //End of namespace Diagnostics

} //End of namespace AMM
