// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file AMM.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "AMM.h"

#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

FMA_Location::FMA_Location()
{
    m_id = 0;

}

FMA_Location::~FMA_Location()
{
}

FMA_Location::FMA_Location(const FMA_Location &x)
{
    m_id = x.m_id;
    m_description = x.m_description;
}

FMA_Location::FMA_Location(FMA_Location &&x)
{
    m_id = x.m_id;
    m_description = std::move(x.m_description);
}

FMA_Location& FMA_Location::operator=(const FMA_Location &x)
{
    m_id = x.m_id;
    m_description = x.m_description;
    
    return *this;
}

FMA_Location& FMA_Location::operator=(FMA_Location &&x)
{
    m_id = x.m_id;
    m_description = std::move(x.m_description);
    
    return *this;
}

size_t FMA_Location::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t FMA_Location::getCdrSerializedSize(const FMA_Location& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.description().size() + 1;


    return current_alignment - initial_alignment;
}

void FMA_Location::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
    scdr << m_description;
}

void FMA_Location::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
    dcdr >> m_description;
}

size_t FMA_Location::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool FMA_Location::isKeyDefined()
{
    return false;
}

void FMA_Location::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
UUID::UUID()
{
    m_UUID_MSB = 0;
    m_UUID_LSB = 0;
}

UUID::~UUID()
{
}

UUID::UUID(const UUID &x)
{
    m_UUID_MSB = x.m_UUID_MSB;
    m_UUID_LSB = x.m_UUID_LSB;
}

UUID::UUID(UUID &&x)
{
    m_UUID_MSB = x.m_UUID_MSB;
    m_UUID_LSB = x.m_UUID_LSB;
}

UUID& UUID::operator=(const UUID &x)
{
    m_UUID_MSB = x.m_UUID_MSB;
    m_UUID_LSB = x.m_UUID_LSB;
    
    return *this;
}

UUID& UUID::operator=(UUID &&x)
{
    m_UUID_MSB = x.m_UUID_MSB;
    m_UUID_LSB = x.m_UUID_LSB;
    
    return *this;
}

size_t UUID::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t UUID::getCdrSerializedSize(const UUID& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void UUID::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_UUID_MSB;
    scdr << m_UUID_LSB;
}

void UUID::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_UUID_MSB;
    dcdr >> m_UUID_LSB;
}

size_t UUID::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool UUID::isKeyDefined()
{
    return false;
}

void UUID::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
AMM::Event::Fragment::Fragment()
{

    m_timestamp = 0.0;




}

AMM::Event::Fragment::~Fragment()
{
}

AMM::Event::Fragment::Fragment(const Fragment &x)
{
    m_id = x.m_id;
    m_timestamp = x.m_timestamp;
    m_location = x.m_location;
    m_learner_id = x.m_learner_id;
    m_fragment_type = x.m_fragment_type;
    m_payload = x.m_payload;
}

AMM::Event::Fragment::Fragment(Fragment &&x)
{
    m_id = std::move(x.m_id);
    m_timestamp = x.m_timestamp;
    m_location = std::move(x.m_location);
    m_learner_id = std::move(x.m_learner_id);
    m_fragment_type = std::move(x.m_fragment_type);
    m_payload = std::move(x.m_payload);
}

AMM::Event::Fragment& AMM::Event::Fragment::operator=(const Fragment &x)
{
    m_id = x.m_id;
    m_timestamp = x.m_timestamp;
    m_location = x.m_location;
    m_learner_id = x.m_learner_id;
    m_fragment_type = x.m_fragment_type;
    m_payload = x.m_payload;
    
    return *this;
}

AMM::Event::Fragment& AMM::Event::Fragment::operator=(Fragment &&x)
{
    m_id = std::move(x.m_id);
    m_timestamp = x.m_timestamp;
    m_location = std::move(x.m_location);
    m_learner_id = std::move(x.m_learner_id);
    m_fragment_type = std::move(x.m_fragment_type);
    m_payload = std::move(x.m_payload);
    
    return *this;
}

size_t AMM::Event::Fragment::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Event::Fragment::getCdrSerializedSize(const AMM::Event::Fragment& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.learner_id().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.fragment_type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.payload().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Event::Fragment::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
    scdr << m_timestamp;
    scdr << m_location;
    scdr << m_learner_id;
    scdr << m_fragment_type;
    scdr << m_payload;
}

void AMM::Event::Fragment::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
    dcdr >> m_timestamp;
    dcdr >> m_location;
    dcdr >> m_learner_id;
    dcdr >> m_fragment_type;
    dcdr >> m_payload;
}

size_t AMM::Event::Fragment::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += UUID::getMaxCdrSerializedSize(current_align); 






    return current_align;
}

bool AMM::Event::Fragment::isKeyDefined()
{
    return true;
}

void AMM::Event::Fragment::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 scdr << m_id;  
	 
	 
	 
	 
	 
}
AMM::Event::FragmentAmendmentRequest::FragmentAmendmentRequest()
{


    m_timestamp = 0.0;





}

AMM::Event::FragmentAmendmentRequest::~FragmentAmendmentRequest()
{
}

AMM::Event::FragmentAmendmentRequest::FragmentAmendmentRequest(const FragmentAmendmentRequest &x)
{
    m_id = x.m_id;
    m_fragment_id = x.m_fragment_id;
    m_timestamp = x.m_timestamp;
    m_status = x.m_status;
    m_location = x.m_location;
    m_learner_id = x.m_learner_id;
    m_fragment_type = x.m_fragment_type;
    m_payload = x.m_payload;
}

AMM::Event::FragmentAmendmentRequest::FragmentAmendmentRequest(FragmentAmendmentRequest &&x)
{
    m_id = std::move(x.m_id);
    m_fragment_id = std::move(x.m_fragment_id);
    m_timestamp = x.m_timestamp;
    m_status = std::move(x.m_status);
    m_location = std::move(x.m_location);
    m_learner_id = std::move(x.m_learner_id);
    m_fragment_type = std::move(x.m_fragment_type);
    m_payload = std::move(x.m_payload);
}

AMM::Event::FragmentAmendmentRequest& AMM::Event::FragmentAmendmentRequest::operator=(const FragmentAmendmentRequest &x)
{
    m_id = x.m_id;
    m_fragment_id = x.m_fragment_id;
    m_timestamp = x.m_timestamp;
    m_status = x.m_status;
    m_location = x.m_location;
    m_learner_id = x.m_learner_id;
    m_fragment_type = x.m_fragment_type;
    m_payload = x.m_payload;
    
    return *this;
}

AMM::Event::FragmentAmendmentRequest& AMM::Event::FragmentAmendmentRequest::operator=(FragmentAmendmentRequest &&x)
{
    m_id = std::move(x.m_id);
    m_fragment_id = std::move(x.m_fragment_id);
    m_timestamp = x.m_timestamp;
    m_status = std::move(x.m_status);
    m_location = std::move(x.m_location);
    m_learner_id = std::move(x.m_learner_id);
    m_fragment_type = std::move(x.m_fragment_type);
    m_payload = std::move(x.m_payload);
    
    return *this;
}

size_t AMM::Event::FragmentAmendmentRequest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Event::FragmentAmendmentRequest::getCdrSerializedSize(const AMM::Event::FragmentAmendmentRequest& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += UUID::getCdrSerializedSize(data.fragment_id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.status().size() + 1;

    current_alignment += FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.learner_id().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.fragment_type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.payload().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Event::FragmentAmendmentRequest::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
    scdr << m_fragment_id;
    scdr << m_timestamp;
    scdr << m_status;
    scdr << m_location;
    scdr << m_learner_id;
    scdr << m_fragment_type;
    scdr << m_payload;
}

void AMM::Event::FragmentAmendmentRequest::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
    dcdr >> m_fragment_id;
    dcdr >> m_timestamp;
    dcdr >> m_status;
    dcdr >> m_location;
    dcdr >> m_learner_id;
    dcdr >> m_fragment_type;
    dcdr >> m_payload;
}

size_t AMM::Event::FragmentAmendmentRequest::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

     current_align += UUID::getMaxCdrSerializedSize(current_align); 







    return current_align;
}

bool AMM::Event::FragmentAmendmentRequest::isKeyDefined()
{
    return true;
}

void AMM::Event::FragmentAmendmentRequest::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 scdr << m_fragment_id;  
	 
	 
	 
	 
	 
	 
}
AMM::Event::Record::Record()
{

    m_timestamp = 0.0;




}

AMM::Event::Record::~Record()
{
}

AMM::Event::Record::Record(const Record &x)
{
    m_id = x.m_id;
    m_timestamp = x.m_timestamp;
    m_location = x.m_location;
    m_learner_id = x.m_learner_id;
    m_record_type = x.m_record_type;
    m_payload = x.m_payload;
}

AMM::Event::Record::Record(Record &&x)
{
    m_id = std::move(x.m_id);
    m_timestamp = x.m_timestamp;
    m_location = std::move(x.m_location);
    m_learner_id = std::move(x.m_learner_id);
    m_record_type = std::move(x.m_record_type);
    m_payload = std::move(x.m_payload);
}

AMM::Event::Record& AMM::Event::Record::operator=(const Record &x)
{
    m_id = x.m_id;
    m_timestamp = x.m_timestamp;
    m_location = x.m_location;
    m_learner_id = x.m_learner_id;
    m_record_type = x.m_record_type;
    m_payload = x.m_payload;
    
    return *this;
}

AMM::Event::Record& AMM::Event::Record::operator=(Record &&x)
{
    m_id = std::move(x.m_id);
    m_timestamp = x.m_timestamp;
    m_location = std::move(x.m_location);
    m_learner_id = std::move(x.m_learner_id);
    m_record_type = std::move(x.m_record_type);
    m_payload = std::move(x.m_payload);
    
    return *this;
}

size_t AMM::Event::Record::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Event::Record::getCdrSerializedSize(const AMM::Event::Record& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.learner_id().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.record_type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.payload().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Event::Record::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
    scdr << m_timestamp;
    scdr << m_location;
    scdr << m_learner_id;
    scdr << m_record_type;
    scdr << m_payload;
}

void AMM::Event::Record::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
    dcdr >> m_timestamp;
    dcdr >> m_location;
    dcdr >> m_learner_id;
    dcdr >> m_record_type;
    dcdr >> m_payload;
}

size_t AMM::Event::Record::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += UUID::getMaxCdrSerializedSize(current_align); 






    return current_align;
}

bool AMM::Event::Record::isKeyDefined()
{
    return true;
}

void AMM::Event::Record::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 scdr << m_id;  
	 
	 
	 
	 
	 
}

AMM::Environment::Settings::Settings()
{
}

AMM::Environment::Settings::~Settings()
{
}

AMM::Environment::Settings::Settings(const Settings &x)
{
    m_description = x.m_description;
}

AMM::Environment::Settings::Settings(Settings &&x)
{
    m_description = std::move(x.m_description);
}

AMM::Environment::Settings& AMM::Environment::Settings::operator=(const Settings &x)
{
    m_description = x.m_description;
    
    return *this;
}

AMM::Environment::Settings& AMM::Environment::Settings::operator=(Settings &&x)
{
    m_description = std::move(x.m_description);
    
    return *this;
}

size_t AMM::Environment::Settings::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t AMM::Environment::Settings::getCdrSerializedSize(const AMM::Environment::Settings& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.description().size() + 1;

    return current_alignment - initial_alignment;
}

void AMM::Environment::Settings::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_description;
}

void AMM::Environment::Settings::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_description;
}

size_t AMM::Environment::Settings::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool AMM::Environment::Settings::isKeyDefined()
{
    return false;
}

void AMM::Environment::Settings::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}

AMM::Simulation::Tick::Tick()
{
    m_frame = 0;
    m_time = 0.0;
}

AMM::Simulation::Tick::~Tick()
{
}

AMM::Simulation::Tick::Tick(const Tick &x)
{
    m_frame = x.m_frame;
    m_time = x.m_time;
}

AMM::Simulation::Tick::Tick(Tick &&x)
{
    m_frame = x.m_frame;
    m_time = x.m_time;
}

AMM::Simulation::Tick& AMM::Simulation::Tick::operator=(const Tick &x)
{
    m_frame = x.m_frame;
    m_time = x.m_time;
    
    return *this;
}

AMM::Simulation::Tick& AMM::Simulation::Tick::operator=(Tick &&x)
{
    m_frame = x.m_frame;
    m_time = x.m_time;
    
    return *this;
}

size_t AMM::Simulation::Tick::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t AMM::Simulation::Tick::getCdrSerializedSize(const AMM::Simulation::Tick& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void AMM::Simulation::Tick::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_frame;
    scdr << m_time;
}

void AMM::Simulation::Tick::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_frame;
    dcdr >> m_time;
}

size_t AMM::Simulation::Tick::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += 8 + eprosima::fastcdr::Cdr::alignment(current_align, 8);
     


    return current_align;
}

bool AMM::Simulation::Tick::isKeyDefined()
{
    return true;
}

void AMM::Simulation::Tick::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 scdr << m_frame;  
	 
}

AMM::InstrumentData::InstrumentData()
{


}

AMM::InstrumentData::~InstrumentData()
{
}

AMM::InstrumentData::InstrumentData(const InstrumentData &x)
{
    m_instrument = x.m_instrument;
    m_payload = x.m_payload;
}

AMM::InstrumentData::InstrumentData(InstrumentData &&x)
{
    m_instrument = std::move(x.m_instrument);
    m_payload = std::move(x.m_payload);
}

AMM::InstrumentData& AMM::InstrumentData::operator=(const InstrumentData &x)
{
    m_instrument = x.m_instrument;
    m_payload = x.m_payload;
    
    return *this;
}

AMM::InstrumentData& AMM::InstrumentData::operator=(InstrumentData &&x)
{
    m_instrument = std::move(x.m_instrument);
    m_payload = std::move(x.m_payload);
    
    return *this;
}

size_t AMM::InstrumentData::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::InstrumentData::getCdrSerializedSize(const AMM::InstrumentData& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.instrument().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.payload().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::InstrumentData::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_instrument;
    scdr << m_payload;
}

void AMM::InstrumentData::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_instrument;
    dcdr >> m_payload;
}

size_t AMM::InstrumentData::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool AMM::InstrumentData::isKeyDefined()
{
    return false;
}

void AMM::InstrumentData::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}


AMM::Physiology::Command::Command()
{
    m_type = AMM::Physiology::PainCommand;

}

AMM::Physiology::Command::~Command()
{
}

AMM::Physiology::Command::Command(const Command &x)
{
    m_type = x.m_type;
    m_payload = x.m_payload;
}

AMM::Physiology::Command::Command(Command &&x)
{
    m_type = x.m_type;
    m_payload = std::move(x.m_payload);
}

AMM::Physiology::Command& AMM::Physiology::Command::operator=(const Command &x)
{
    m_type = x.m_type;
    m_payload = x.m_payload;
    
    return *this;
}

AMM::Physiology::Command& AMM::Physiology::Command::operator=(Command &&x)
{
    m_type = x.m_type;
    m_payload = std::move(x.m_payload);
    
    return *this;
}

size_t AMM::Physiology::Command::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t AMM::Physiology::Command::getCdrSerializedSize(const AMM::Physiology::Command& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.payload().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void AMM::Physiology::Command::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << (uint32_t)m_type;
    scdr << m_payload;
}

void AMM::Physiology::Command::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> (uint32_t&)m_type;
    dcdr >> m_payload;
}

size_t AMM::Physiology::Command::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool AMM::Physiology::Command::isKeyDefined()
{
    return false;
}

void AMM::Physiology::Command::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
AMM::Physiology::PainStimulus::Data::Data()
{

    m_severity = 0.0;
}

AMM::Physiology::PainStimulus::Data::~Data()
{
}

AMM::Physiology::PainStimulus::Data::Data(const Data &x)
{
    m_location = x.m_location;
    m_severity = x.m_severity;
}

AMM::Physiology::PainStimulus::Data::Data(Data &&x)
{
    m_location = std::move(x.m_location);
    m_severity = x.m_severity;
}

AMM::Physiology::PainStimulus::Data& AMM::Physiology::PainStimulus::Data::operator=(const Data &x)
{
    m_location = x.m_location;
    m_severity = x.m_severity;
    
    return *this;
}

AMM::Physiology::PainStimulus::Data& AMM::Physiology::PainStimulus::Data::operator=(Data &&x)
{
    m_location = std::move(x.m_location);
    m_severity = x.m_severity;
    
    return *this;
}

size_t AMM::Physiology::PainStimulus::Data::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Physiology::PainStimulus::Data::getCdrSerializedSize(const AMM::Physiology::PainStimulus::Data& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Physiology::PainStimulus::Data::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_location;
    scdr << m_severity;
}

void AMM::Physiology::PainStimulus::Data::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_location;
    dcdr >> m_severity;
}

size_t AMM::Physiology::PainStimulus::Data::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool AMM::Physiology::PainStimulus::Data::isKeyDefined()
{
    return false;
}

void AMM::Physiology::PainStimulus::Data::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}

AMM::Physiology::Sepsis::Data::Data()
{
    m_location = AMM::Physiology::BoneTissue;
    m_severity = 0.0;
}

AMM::Physiology::Sepsis::Data::~Data()
{
}

AMM::Physiology::Sepsis::Data::Data(const Data &x)
{
    m_location = x.m_location;
    m_severity = x.m_severity;
}

AMM::Physiology::Sepsis::Data::Data(Data &&x)
{
    m_location = x.m_location;
    m_severity = x.m_severity;
}

AMM::Physiology::Sepsis::Data& AMM::Physiology::Sepsis::Data::operator=(const Data &x)
{
    m_location = x.m_location;
    m_severity = x.m_severity;
    
    return *this;
}

AMM::Physiology::Sepsis::Data& AMM::Physiology::Sepsis::Data::operator=(Data &&x)
{
    m_location = x.m_location;
    m_severity = x.m_severity;
    
    return *this;
}

size_t AMM::Physiology::Sepsis::Data::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Physiology::Sepsis::Data::getCdrSerializedSize(const AMM::Physiology::Sepsis::Data& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Physiology::Sepsis::Data::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << (uint32_t)m_location;
    scdr << m_severity;
}

void AMM::Physiology::Sepsis::Data::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> (uint32_t&)m_location;
    dcdr >> m_severity;
}

size_t AMM::Physiology::Sepsis::Data::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool AMM::Physiology::Sepsis::Data::isKeyDefined()
{
    return false;
}

void AMM::Physiology::Sepsis::Data::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}

AMM::Physiology::Modification::Modification()
{





}

AMM::Physiology::Modification::~Modification()
{
}

AMM::Physiology::Modification::Modification(const Modification &x)
{
    m_id = x.m_id;
    m_location = x.m_location;
    m_practitioner = x.m_practitioner;
    m_type = x.m_type;
    m_payload = x.m_payload;
}

AMM::Physiology::Modification::Modification(Modification &&x)
{
    m_id = std::move(x.m_id);
    m_location = std::move(x.m_location);
    m_practitioner = std::move(x.m_practitioner);
    m_type = std::move(x.m_type);
    m_payload = std::move(x.m_payload);
}

AMM::Physiology::Modification& AMM::Physiology::Modification::operator=(const Modification &x)
{
    m_id = x.m_id;
    m_location = x.m_location;
    m_practitioner = x.m_practitioner;
    m_type = x.m_type;
    m_payload = x.m_payload;
    
    return *this;
}

AMM::Physiology::Modification& AMM::Physiology::Modification::operator=(Modification &&x)
{
    m_id = std::move(x.m_id);
    m_location = std::move(x.m_location);
    m_practitioner = std::move(x.m_practitioner);
    m_type = std::move(x.m_type);
    m_payload = std::move(x.m_payload);
    
    return *this;
}

size_t AMM::Physiology::Modification::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Physiology::Modification::getCdrSerializedSize(const AMM::Physiology::Modification& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.practitioner().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.payload().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Physiology::Modification::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
    scdr << m_location;
    scdr << m_practitioner;
    scdr << m_type;
    scdr << m_payload;
}

void AMM::Physiology::Modification::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
    dcdr >> m_location;
    dcdr >> m_practitioner;
    dcdr >> m_type;
    dcdr >> m_payload;
}

size_t AMM::Physiology::Modification::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            






    return current_align;
}

bool AMM::Physiology::Modification::isKeyDefined()
{
    return false;
}

void AMM::Physiology::Modification::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
	 
	 
}
AMM::Physiology::Node::Node()
{
    m_frame = 0;


    m_dbl = 0.0;

}

AMM::Physiology::Node::~Node()
{
}

AMM::Physiology::Node::Node(const Node &x)
{
    m_frame = x.m_frame;
    m_nodepath = x.m_nodepath;
    m_unit = x.m_unit;
    m_dbl = x.m_dbl;
    m_str = x.m_str;
}

AMM::Physiology::Node::Node(Node &&x)
{
    m_frame = x.m_frame;
    m_nodepath = std::move(x.m_nodepath);
    m_unit = std::move(x.m_unit);
    m_dbl = x.m_dbl;
    m_str = std::move(x.m_str);
}

AMM::Physiology::Node& AMM::Physiology::Node::operator=(const Node &x)
{
    m_frame = x.m_frame;
    m_nodepath = x.m_nodepath;
    m_unit = x.m_unit;
    m_dbl = x.m_dbl;
    m_str = x.m_str;
    
    return *this;
}

AMM::Physiology::Node& AMM::Physiology::Node::operator=(Node &&x)
{
    m_frame = x.m_frame;
    m_nodepath = std::move(x.m_nodepath);
    m_unit = std::move(x.m_unit);
    m_dbl = x.m_dbl;
    m_str = std::move(x.m_str);
    
    return *this;
}

size_t AMM::Physiology::Node::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Physiology::Node::getCdrSerializedSize(const AMM::Physiology::Node& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.nodepath().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.unit().size() + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.str().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Physiology::Node::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_frame;
    scdr << m_nodepath;
    scdr << m_unit;
    scdr << m_dbl;
    scdr << m_str;
}

void AMM::Physiology::Node::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_frame;
    dcdr >> m_nodepath;
    dcdr >> m_unit;
    dcdr >> m_dbl;
    dcdr >> m_str;
}

size_t AMM::Physiology::Node::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += 8 + eprosima::fastcdr::Cdr::alignment(current_align, 8);
     
     current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4) + 255 + 1;
     




    return current_align;
}

bool AMM::Physiology::Node::isKeyDefined()
{
    return true;
}

void AMM::Physiology::Node::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 scdr << m_frame;  
	 scdr << m_nodepath;  
	 
	 
	 
}
AMM::Physiology::HighFrequencyNode::HighFrequencyNode()
{
    m_frame = 0;


    m_dbl = 0.0;

}

AMM::Physiology::HighFrequencyNode::~HighFrequencyNode()
{
}

AMM::Physiology::HighFrequencyNode::HighFrequencyNode(const HighFrequencyNode &x)
{
    m_frame = x.m_frame;
    m_nodepath = x.m_nodepath;
    m_unit = x.m_unit;
    m_dbl = x.m_dbl;
    m_str = x.m_str;
}

AMM::Physiology::HighFrequencyNode::HighFrequencyNode(HighFrequencyNode &&x)
{
    m_frame = x.m_frame;
    m_nodepath = std::move(x.m_nodepath);
    m_unit = std::move(x.m_unit);
    m_dbl = x.m_dbl;
    m_str = std::move(x.m_str);
}

AMM::Physiology::HighFrequencyNode& AMM::Physiology::HighFrequencyNode::operator=(const HighFrequencyNode &x)
{
    m_frame = x.m_frame;
    m_nodepath = x.m_nodepath;
    m_unit = x.m_unit;
    m_dbl = x.m_dbl;
    m_str = x.m_str;
    
    return *this;
}

AMM::Physiology::HighFrequencyNode& AMM::Physiology::HighFrequencyNode::operator=(HighFrequencyNode &&x)
{
    m_frame = x.m_frame;
    m_nodepath = std::move(x.m_nodepath);
    m_unit = std::move(x.m_unit);
    m_dbl = x.m_dbl;
    m_str = std::move(x.m_str);
    
    return *this;
}

size_t AMM::Physiology::HighFrequencyNode::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Physiology::HighFrequencyNode::getCdrSerializedSize(const AMM::Physiology::HighFrequencyNode& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.nodepath().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.unit().size() + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.str().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Physiology::HighFrequencyNode::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_frame;
    scdr << m_nodepath;
    scdr << m_unit;
    scdr << m_dbl;
    scdr << m_str;
}

void AMM::Physiology::HighFrequencyNode::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_frame;
    dcdr >> m_nodepath;
    dcdr >> m_unit;
    dcdr >> m_dbl;
    dcdr >> m_str;
}

size_t AMM::Physiology::HighFrequencyNode::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            
     current_align += 8 + eprosima::fastcdr::Cdr::alignment(current_align, 8);
     
     current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4) + 255 + 1;
     




    return current_align;
}

bool AMM::Physiology::HighFrequencyNode::isKeyDefined()
{
    return true;
}

void AMM::Physiology::HighFrequencyNode::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 scdr << m_frame;  
	 scdr << m_nodepath;  
	 
	 
	 
}

AMM::Render::Modification::Modification()
{





}

AMM::Render::Modification::~Modification()
{
}

AMM::Render::Modification::Modification(const Modification &x)
{
    m_id = x.m_id;
    m_location = x.m_location;
    m_practitioner = x.m_practitioner;
    m_type = x.m_type;
    m_payload = x.m_payload;
}

AMM::Render::Modification::Modification(Modification &&x)
{
    m_id = std::move(x.m_id);
    m_location = std::move(x.m_location);
    m_practitioner = std::move(x.m_practitioner);
    m_type = std::move(x.m_type);
    m_payload = std::move(x.m_payload);
}

AMM::Render::Modification& AMM::Render::Modification::operator=(const Modification &x)
{
    m_id = x.m_id;
    m_location = x.m_location;
    m_practitioner = x.m_practitioner;
    m_type = x.m_type;
    m_payload = x.m_payload;
    
    return *this;
}

AMM::Render::Modification& AMM::Render::Modification::operator=(Modification &&x)
{
    m_id = std::move(x.m_id);
    m_location = std::move(x.m_location);
    m_practitioner = std::move(x.m_practitioner);
    m_type = std::move(x.m_type);
    m_payload = std::move(x.m_payload);
    
    return *this;
}

size_t AMM::Render::Modification::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Render::Modification::getCdrSerializedSize(const AMM::Render::Modification& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.practitioner().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.payload().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Render::Modification::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
    scdr << m_location;
    scdr << m_practitioner;
    scdr << m_type;
    scdr << m_payload;
}

void AMM::Render::Modification::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
    dcdr >> m_location;
    dcdr >> m_practitioner;
    dcdr >> m_type;
    dcdr >> m_payload;
}

size_t AMM::Render::Modification::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            






    return current_align;
}

bool AMM::Render::Modification::isKeyDefined()
{
    return false;
}

void AMM::Render::Modification::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
	 
	 
}

AMM::PatientAction::BioGears::Command::Command()
{
}

AMM::PatientAction::BioGears::Command::~Command()
{
}

AMM::PatientAction::BioGears::Command::Command(const Command &x)
{
    m_message = x.m_message;
}

AMM::PatientAction::BioGears::Command::Command(Command &&x)
{
    m_message = std::move(x.m_message);
}

AMM::PatientAction::BioGears::Command& AMM::PatientAction::BioGears::Command::operator=(const Command &x)
{
    m_message = x.m_message;
    
    return *this;
}

AMM::PatientAction::BioGears::Command& AMM::PatientAction::BioGears::Command::operator=(Command &&x)
{
    m_message = std::move(x.m_message);
    
    return *this;
}

size_t AMM::PatientAction::BioGears::Command::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t AMM::PatientAction::BioGears::Command::getCdrSerializedSize(const AMM::PatientAction::BioGears::Command& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.message().size() + 1;

    return current_alignment - initial_alignment;
}

void AMM::PatientAction::BioGears::Command::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_message;
}

void AMM::PatientAction::BioGears::Command::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_message;
}

size_t AMM::PatientAction::BioGears::Command::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool AMM::PatientAction::BioGears::Command::isKeyDefined()
{
    return false;
}

void AMM::PatientAction::BioGears::Command::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}


AMM::Performance::xAPIModifier::xAPIModifier()
{


}

AMM::Performance::xAPIModifier::~xAPIModifier()
{
}

AMM::Performance::xAPIModifier::xAPIModifier(const xAPIModifier &x)
{
    m_key = x.m_key;
    m_value = x.m_value;
}

AMM::Performance::xAPIModifier::xAPIModifier(xAPIModifier &&x)
{
    m_key = std::move(x.m_key);
    m_value = std::move(x.m_value);
}

AMM::Performance::xAPIModifier& AMM::Performance::xAPIModifier::operator=(const xAPIModifier &x)
{
    m_key = x.m_key;
    m_value = x.m_value;
    
    return *this;
}

AMM::Performance::xAPIModifier& AMM::Performance::xAPIModifier::operator=(xAPIModifier &&x)
{
    m_key = std::move(x.m_key);
    m_value = std::move(x.m_value);
    
    return *this;
}

size_t AMM::Performance::xAPIModifier::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Performance::xAPIModifier::getCdrSerializedSize(const AMM::Performance::xAPIModifier& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.key().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.value().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Performance::xAPIModifier::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_key;
    scdr << m_value;
}

void AMM::Performance::xAPIModifier::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_key;
    dcdr >> m_value;
}

size_t AMM::Performance::xAPIModifier::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool AMM::Performance::xAPIModifier::isKeyDefined()
{
    return false;
}

void AMM::Performance::xAPIModifier::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}

AMM::Performance::Statement::Statement()
{






}

AMM::Performance::Statement::~Statement()
{
}

AMM::Performance::Statement::Statement(const Statement &x)
{
    m_noun = x.m_noun;
    m_noun_modifiers = x.m_noun_modifiers;
    m_verb = x.m_verb;
    m_verb_modifiers = x.m_verb_modifiers;
    m_obj = x.m_obj;
    m_obj_modifiers = x.m_obj_modifiers;
}

AMM::Performance::Statement::Statement(Statement &&x)
{
    m_noun = std::move(x.m_noun);
    m_noun_modifiers = std::move(x.m_noun_modifiers);
    m_verb = std::move(x.m_verb);
    m_verb_modifiers = std::move(x.m_verb_modifiers);
    m_obj = std::move(x.m_obj);
    m_obj_modifiers = std::move(x.m_obj_modifiers);
}

AMM::Performance::Statement& AMM::Performance::Statement::operator=(const Statement &x)
{
    m_noun = x.m_noun;
    m_noun_modifiers = x.m_noun_modifiers;
    m_verb = x.m_verb;
    m_verb_modifiers = x.m_verb_modifiers;
    m_obj = x.m_obj;
    m_obj_modifiers = x.m_obj_modifiers;
    
    return *this;
}

AMM::Performance::Statement& AMM::Performance::Statement::operator=(Statement &&x)
{
    m_noun = std::move(x.m_noun);
    m_noun_modifiers = std::move(x.m_noun_modifiers);
    m_verb = std::move(x.m_verb);
    m_verb_modifiers = std::move(x.m_verb_modifiers);
    m_obj = std::move(x.m_obj);
    m_obj_modifiers = std::move(x.m_obj_modifiers);
    
    return *this;
}

size_t AMM::Performance::Statement::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += AMM::Performance::xAPIModifier::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += AMM::Performance::xAPIModifier::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += AMM::Performance::xAPIModifier::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t AMM::Performance::Statement::getCdrSerializedSize(const AMM::Performance::Statement& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.noun().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.noun_modifiers().size(); ++a)
    {
        current_alignment += AMM::Performance::xAPIModifier::getCdrSerializedSize(data.noun_modifiers().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.verb().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.verb_modifiers().size(); ++a)
    {
        current_alignment += AMM::Performance::xAPIModifier::getCdrSerializedSize(data.verb_modifiers().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.obj().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.obj_modifiers().size(); ++a)
    {
        current_alignment += AMM::Performance::xAPIModifier::getCdrSerializedSize(data.obj_modifiers().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void AMM::Performance::Statement::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_noun;
    scdr << m_noun_modifiers;
    scdr << m_verb;
    scdr << m_verb_modifiers;
    scdr << m_obj;
    scdr << m_obj_modifiers;
}

void AMM::Performance::Statement::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_noun;
    dcdr >> m_noun_modifiers;
    dcdr >> m_verb;
    dcdr >> m_verb_modifiers;
    dcdr >> m_obj;
    dcdr >> m_obj_modifiers;
}

size_t AMM::Performance::Statement::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            







    return current_align;
}

bool AMM::Performance::Statement::isKeyDefined()
{
    return false;
}

void AMM::Performance::Statement::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
	 
	 
	 
}
AMM::Performance::Assessment::Assessment()
{







}

AMM::Performance::Assessment::~Assessment()
{
}

AMM::Performance::Assessment::Assessment(const Assessment &x)
{
    m_Timestamp = x.m_Timestamp;
    m_learner_id = x.m_learner_id;
    m_location = x.m_location;
    m_assessment_type = x.m_assessment_type;
    m_assessment_info = x.m_assessment_info;
    m_step = x.m_step;
    m_comment = x.m_comment;
}

AMM::Performance::Assessment::Assessment(Assessment &&x)
{
    m_Timestamp = std::move(x.m_Timestamp);
    m_learner_id = std::move(x.m_learner_id);
    m_location = std::move(x.m_location);
    m_assessment_type = std::move(x.m_assessment_type);
    m_assessment_info = std::move(x.m_assessment_info);
    m_step = std::move(x.m_step);
    m_comment = std::move(x.m_comment);
}

AMM::Performance::Assessment& AMM::Performance::Assessment::operator=(const Assessment &x)
{
    m_Timestamp = x.m_Timestamp;
    m_learner_id = x.m_learner_id;
    m_location = x.m_location;
    m_assessment_type = x.m_assessment_type;
    m_assessment_info = x.m_assessment_info;
    m_step = x.m_step;
    m_comment = x.m_comment;
    
    return *this;
}

AMM::Performance::Assessment& AMM::Performance::Assessment::operator=(Assessment &&x)
{
    m_Timestamp = std::move(x.m_Timestamp);
    m_learner_id = std::move(x.m_learner_id);
    m_location = std::move(x.m_location);
    m_assessment_type = std::move(x.m_assessment_type);
    m_assessment_info = std::move(x.m_assessment_info);
    m_step = std::move(x.m_step);
    m_comment = std::move(x.m_comment);
    
    return *this;
}

size_t AMM::Performance::Assessment::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Performance::Assessment::getCdrSerializedSize(const AMM::Performance::Assessment& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.Timestamp().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.learner_id().size() + 1;

    current_alignment += FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.assessment_type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.assessment_info().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.step().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.comment().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Performance::Assessment::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_Timestamp;
    scdr << m_learner_id;
    scdr << m_location;
    scdr << m_assessment_type;
    scdr << m_assessment_info;
    scdr << m_step;
    scdr << m_comment;
}

void AMM::Performance::Assessment::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_Timestamp;
    dcdr >> m_learner_id;
    dcdr >> m_location;
    dcdr >> m_assessment_type;
    dcdr >> m_assessment_info;
    dcdr >> m_step;
    dcdr >> m_comment;
}

size_t AMM::Performance::Assessment::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            








    return current_align;
}

bool AMM::Performance::Assessment::isKeyDefined()
{
    return false;
}

void AMM::Performance::Assessment::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
	 
	 
	 
	 
}

AMM::Resource::Requirement::Power::Power()
{
    m_volts = 0.0;
    m_amps = 0.0;
}

AMM::Resource::Requirement::Power::~Power()
{
}

AMM::Resource::Requirement::Power::Power(const Power &x)
{
    m_volts = x.m_volts;
    m_amps = x.m_amps;
}

AMM::Resource::Requirement::Power::Power(Power &&x)
{
    m_volts = x.m_volts;
    m_amps = x.m_amps;
}

AMM::Resource::Requirement::Power& AMM::Resource::Requirement::Power::operator=(const Power &x)
{
    m_volts = x.m_volts;
    m_amps = x.m_amps;
    
    return *this;
}

AMM::Resource::Requirement::Power& AMM::Resource::Requirement::Power::operator=(Power &&x)
{
    m_volts = x.m_volts;
    m_amps = x.m_amps;
    
    return *this;
}

size_t AMM::Resource::Requirement::Power::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Requirement::Power::getCdrSerializedSize(const AMM::Resource::Requirement::Power& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Requirement::Power::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_volts;
    scdr << m_amps;
}

void AMM::Resource::Requirement::Power::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_volts;
    dcdr >> m_amps;
}

size_t AMM::Resource::Requirement::Power::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool AMM::Resource::Requirement::Power::isKeyDefined()
{
    return false;
}

void AMM::Resource::Requirement::Power::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
AMM::Resource::Requirement::Blood::Blood()
{
    m_volume = 0.0;
}

AMM::Resource::Requirement::Blood::~Blood()
{
}

AMM::Resource::Requirement::Blood::Blood(const Blood &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Blood::Blood(Blood &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Blood& AMM::Resource::Requirement::Blood::operator=(const Blood &x)
{
    m_volume = x.m_volume;
    
    return *this;
}

AMM::Resource::Requirement::Blood& AMM::Resource::Requirement::Blood::operator=(Blood &&x)
{
    m_volume = x.m_volume;
    
    return *this;
}

size_t AMM::Resource::Requirement::Blood::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Requirement::Blood::getCdrSerializedSize(const AMM::Resource::Requirement::Blood& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Requirement::Blood::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_volume;
}

void AMM::Resource::Requirement::Blood::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_volume;
}

size_t AMM::Resource::Requirement::Blood::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool AMM::Resource::Requirement::Blood::isKeyDefined()
{
    return false;
}

void AMM::Resource::Requirement::Blood::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}
AMM::Resource::Requirement::Clear_Liquid::Clear_Liquid()
{
    m_volume = 0.0;
}

AMM::Resource::Requirement::Clear_Liquid::~Clear_Liquid()
{
}

AMM::Resource::Requirement::Clear_Liquid::Clear_Liquid(const Clear_Liquid &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Clear_Liquid::Clear_Liquid(Clear_Liquid &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Clear_Liquid& AMM::Resource::Requirement::Clear_Liquid::operator=(const Clear_Liquid &x)
{
    m_volume = x.m_volume;
    
    return *this;
}

AMM::Resource::Requirement::Clear_Liquid& AMM::Resource::Requirement::Clear_Liquid::operator=(Clear_Liquid &&x)
{
    m_volume = x.m_volume;
    
    return *this;
}

size_t AMM::Resource::Requirement::Clear_Liquid::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Requirement::Clear_Liquid::getCdrSerializedSize(const AMM::Resource::Requirement::Clear_Liquid& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Requirement::Clear_Liquid::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_volume;
}

void AMM::Resource::Requirement::Clear_Liquid::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_volume;
}

size_t AMM::Resource::Requirement::Clear_Liquid::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool AMM::Resource::Requirement::Clear_Liquid::isKeyDefined()
{
    return false;
}

void AMM::Resource::Requirement::Clear_Liquid::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}
AMM::Resource::Requirement::Air::Air()
{
    m_volume = 0.0;
}

AMM::Resource::Requirement::Air::~Air()
{
}

AMM::Resource::Requirement::Air::Air(const Air &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Air::Air(Air &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Air& AMM::Resource::Requirement::Air::operator=(const Air &x)
{
    m_volume = x.m_volume;
    
    return *this;
}

AMM::Resource::Requirement::Air& AMM::Resource::Requirement::Air::operator=(Air &&x)
{
    m_volume = x.m_volume;
    
    return *this;
}

size_t AMM::Resource::Requirement::Air::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Requirement::Air::getCdrSerializedSize(const AMM::Resource::Requirement::Air& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Requirement::Air::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_volume;
}

void AMM::Resource::Requirement::Air::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_volume;
}

size_t AMM::Resource::Requirement::Air::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool AMM::Resource::Requirement::Air::isKeyDefined()
{
    return false;
}

void AMM::Resource::Requirement::Air::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}
AMM::Resource::Requirement::Cleaning_Solution::Cleaning_Solution()
{
    m_volume = 0.0;
}

AMM::Resource::Requirement::Cleaning_Solution::~Cleaning_Solution()
{
}

AMM::Resource::Requirement::Cleaning_Solution::Cleaning_Solution(const Cleaning_Solution &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Cleaning_Solution::Cleaning_Solution(Cleaning_Solution &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Cleaning_Solution& AMM::Resource::Requirement::Cleaning_Solution::operator=(const Cleaning_Solution &x)
{
    m_volume = x.m_volume;
    
    return *this;
}

AMM::Resource::Requirement::Cleaning_Solution& AMM::Resource::Requirement::Cleaning_Solution::operator=(Cleaning_Solution &&x)
{
    m_volume = x.m_volume;
    
    return *this;
}

size_t AMM::Resource::Requirement::Cleaning_Solution::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Requirement::Cleaning_Solution::getCdrSerializedSize(const AMM::Resource::Requirement::Cleaning_Solution& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Requirement::Cleaning_Solution::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_volume;
}

void AMM::Resource::Requirement::Cleaning_Solution::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_volume;
}

size_t AMM::Resource::Requirement::Cleaning_Solution::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool AMM::Resource::Requirement::Cleaning_Solution::isKeyDefined()
{
    return false;
}

void AMM::Resource::Requirement::Cleaning_Solution::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}

AMM::Resource::Supply::Power::Power()
{
    m_volts = 0.0;
    m_amps = 0.0;
}

AMM::Resource::Supply::Power::~Power()
{
}

AMM::Resource::Supply::Power::Power(const Power &x)
{
    m_volts = x.m_volts;
    m_amps = x.m_amps;
}

AMM::Resource::Supply::Power::Power(Power &&x)
{
    m_volts = x.m_volts;
    m_amps = x.m_amps;
}

AMM::Resource::Supply::Power& AMM::Resource::Supply::Power::operator=(const Power &x)
{
    m_volts = x.m_volts;
    m_amps = x.m_amps;
    
    return *this;
}

AMM::Resource::Supply::Power& AMM::Resource::Supply::Power::operator=(Power &&x)
{
    m_volts = x.m_volts;
    m_amps = x.m_amps;
    
    return *this;
}

size_t AMM::Resource::Supply::Power::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Supply::Power::getCdrSerializedSize(const AMM::Resource::Supply::Power& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Supply::Power::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_volts;
    scdr << m_amps;
}

void AMM::Resource::Supply::Power::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_volts;
    dcdr >> m_amps;
}

size_t AMM::Resource::Supply::Power::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool AMM::Resource::Supply::Power::isKeyDefined()
{
    return false;
}

void AMM::Resource::Supply::Power::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
AMM::Resource::Supply::Blood::Blood()
{
    m_volume = 0.0;
}

AMM::Resource::Supply::Blood::~Blood()
{
}

AMM::Resource::Supply::Blood::Blood(const Blood &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Blood::Blood(Blood &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Blood& AMM::Resource::Supply::Blood::operator=(const Blood &x)
{
    m_volume = x.m_volume;
    
    return *this;
}

AMM::Resource::Supply::Blood& AMM::Resource::Supply::Blood::operator=(Blood &&x)
{
    m_volume = x.m_volume;
    
    return *this;
}

size_t AMM::Resource::Supply::Blood::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Supply::Blood::getCdrSerializedSize(const AMM::Resource::Supply::Blood& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Supply::Blood::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_volume;
}

void AMM::Resource::Supply::Blood::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_volume;
}

size_t AMM::Resource::Supply::Blood::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool AMM::Resource::Supply::Blood::isKeyDefined()
{
    return false;
}

void AMM::Resource::Supply::Blood::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}
AMM::Resource::Supply::Clear_Liquid::Clear_Liquid()
{
    m_volume = 0.0;
}

AMM::Resource::Supply::Clear_Liquid::~Clear_Liquid()
{
}

AMM::Resource::Supply::Clear_Liquid::Clear_Liquid(const Clear_Liquid &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Clear_Liquid::Clear_Liquid(Clear_Liquid &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Clear_Liquid& AMM::Resource::Supply::Clear_Liquid::operator=(const Clear_Liquid &x)
{
    m_volume = x.m_volume;
    
    return *this;
}

AMM::Resource::Supply::Clear_Liquid& AMM::Resource::Supply::Clear_Liquid::operator=(Clear_Liquid &&x)
{
    m_volume = x.m_volume;
    
    return *this;
}

size_t AMM::Resource::Supply::Clear_Liquid::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Supply::Clear_Liquid::getCdrSerializedSize(const AMM::Resource::Supply::Clear_Liquid& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Supply::Clear_Liquid::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_volume;
}

void AMM::Resource::Supply::Clear_Liquid::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_volume;
}

size_t AMM::Resource::Supply::Clear_Liquid::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool AMM::Resource::Supply::Clear_Liquid::isKeyDefined()
{
    return false;
}

void AMM::Resource::Supply::Clear_Liquid::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}
AMM::Resource::Supply::Air::Air()
{
    m_volume = 0.0;
}

AMM::Resource::Supply::Air::~Air()
{
}

AMM::Resource::Supply::Air::Air(const Air &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Air::Air(Air &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Air& AMM::Resource::Supply::Air::operator=(const Air &x)
{
    m_volume = x.m_volume;
    
    return *this;
}

AMM::Resource::Supply::Air& AMM::Resource::Supply::Air::operator=(Air &&x)
{
    m_volume = x.m_volume;
    
    return *this;
}

size_t AMM::Resource::Supply::Air::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Supply::Air::getCdrSerializedSize(const AMM::Resource::Supply::Air& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Supply::Air::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_volume;
}

void AMM::Resource::Supply::Air::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_volume;
}

size_t AMM::Resource::Supply::Air::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool AMM::Resource::Supply::Air::isKeyDefined()
{
    return false;
}

void AMM::Resource::Supply::Air::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}
AMM::Resource::Supply::Cleaning_Solution::Cleaning_Solution()
{
    m_volume = 0.0;
}

AMM::Resource::Supply::Cleaning_Solution::~Cleaning_Solution()
{
}

AMM::Resource::Supply::Cleaning_Solution::Cleaning_Solution(const Cleaning_Solution &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Cleaning_Solution::Cleaning_Solution(Cleaning_Solution &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Cleaning_Solution& AMM::Resource::Supply::Cleaning_Solution::operator=(const Cleaning_Solution &x)
{
    m_volume = x.m_volume;
    
    return *this;
}

AMM::Resource::Supply::Cleaning_Solution& AMM::Resource::Supply::Cleaning_Solution::operator=(Cleaning_Solution &&x)
{
    m_volume = x.m_volume;
    
    return *this;
}

size_t AMM::Resource::Supply::Cleaning_Solution::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Supply::Cleaning_Solution::getCdrSerializedSize(const AMM::Resource::Supply::Cleaning_Solution& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Supply::Cleaning_Solution::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_volume;
}

void AMM::Resource::Supply::Cleaning_Solution::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_volume;
}

size_t AMM::Resource::Supply::Cleaning_Solution::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool AMM::Resource::Supply::Cleaning_Solution::isKeyDefined()
{
    return false;
}

void AMM::Resource::Supply::Cleaning_Solution::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}



AMM::Capability::AMM_version::AMM_version()
{



}

AMM::Capability::AMM_version::~AMM_version()
{
}

AMM::Capability::AMM_version::AMM_version(const AMM_version &x)
{
    m_software_version = x.m_software_version;
    m_hardware_version = x.m_hardware_version;
    m_specification_version = x.m_specification_version;
}

AMM::Capability::AMM_version::AMM_version(AMM_version &&x)
{
    m_software_version = std::move(x.m_software_version);
    m_hardware_version = std::move(x.m_hardware_version);
    m_specification_version = std::move(x.m_specification_version);
}

AMM::Capability::AMM_version& AMM::Capability::AMM_version::operator=(const AMM_version &x)
{
    m_software_version = x.m_software_version;
    m_hardware_version = x.m_hardware_version;
    m_specification_version = x.m_specification_version;
    
    return *this;
}

AMM::Capability::AMM_version& AMM::Capability::AMM_version::operator=(AMM_version &&x)
{
    m_software_version = std::move(x.m_software_version);
    m_hardware_version = std::move(x.m_hardware_version);
    m_specification_version = std::move(x.m_specification_version);
    
    return *this;
}

size_t AMM::Capability::AMM_version::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Capability::AMM_version::getCdrSerializedSize(const AMM::Capability::AMM_version& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.software_version().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.hardware_version().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.specification_version().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Capability::AMM_version::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_software_version;
    scdr << m_hardware_version;
    scdr << m_specification_version;
}

void AMM::Capability::AMM_version::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_software_version;
    dcdr >> m_hardware_version;
    dcdr >> m_specification_version;
}

size_t AMM::Capability::AMM_version::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool AMM::Capability::AMM_version::isKeyDefined()
{
    return false;
}

void AMM::Capability::AMM_version::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
}
AMM::Capability::Configuration::Configuration()
{








}

AMM::Capability::Configuration::~Configuration()
{
}

AMM::Capability::Configuration::Configuration(const Configuration &x)
{
    m_module_id = x.m_module_id;
    m_module_name = x.m_module_name;
    m_manufacturer = x.m_manufacturer;
    m_model = x.m_model;
    m_serial_number = x.m_serial_number;
    m_version = x.m_version;
    m_amm_version = x.m_amm_version;
    m_capabilities = x.m_capabilities;
}

AMM::Capability::Configuration::Configuration(Configuration &&x)
{
    m_module_id = std::move(x.m_module_id);
    m_module_name = std::move(x.m_module_name);
    m_manufacturer = std::move(x.m_manufacturer);
    m_model = std::move(x.m_model);
    m_serial_number = std::move(x.m_serial_number);
    m_version = std::move(x.m_version);
    m_amm_version = std::move(x.m_amm_version);
    m_capabilities = std::move(x.m_capabilities);
}

AMM::Capability::Configuration& AMM::Capability::Configuration::operator=(const Configuration &x)
{
    m_module_id = x.m_module_id;
    m_module_name = x.m_module_name;
    m_manufacturer = x.m_manufacturer;
    m_model = x.m_model;
    m_serial_number = x.m_serial_number;
    m_version = x.m_version;
    m_amm_version = x.m_amm_version;
    m_capabilities = x.m_capabilities;
    
    return *this;
}

AMM::Capability::Configuration& AMM::Capability::Configuration::operator=(Configuration &&x)
{
    m_module_id = std::move(x.m_module_id);
    m_module_name = std::move(x.m_module_name);
    m_manufacturer = std::move(x.m_manufacturer);
    m_model = std::move(x.m_model);
    m_serial_number = std::move(x.m_serial_number);
    m_version = std::move(x.m_version);
    m_amm_version = std::move(x.m_amm_version);
    m_capabilities = std::move(x.m_capabilities);
    
    return *this;
}

size_t AMM::Capability::Configuration::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += AMM::Capability::AMM_version::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Capability::Configuration::getCdrSerializedSize(const AMM::Capability::Configuration& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.module_id().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.module_name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.manufacturer().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.model().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.serial_number().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.version().size() + 1;

    current_alignment += AMM::Capability::AMM_version::getCdrSerializedSize(data.amm_version(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.capabilities().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Capability::Configuration::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_module_id;
    scdr << m_module_name;
    scdr << m_manufacturer;
    scdr << m_model;
    scdr << m_serial_number;
    scdr << m_version;
    scdr << m_amm_version;
    scdr << m_capabilities;
}

void AMM::Capability::Configuration::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_module_id;
    dcdr >> m_module_name;
    dcdr >> m_manufacturer;
    dcdr >> m_model;
    dcdr >> m_serial_number;
    dcdr >> m_version;
    dcdr >> m_amm_version;
    dcdr >> m_capabilities;
}

size_t AMM::Capability::Configuration::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            









    return current_align;
}

bool AMM::Capability::Configuration::isKeyDefined()
{
    return false;
}

void AMM::Capability::Configuration::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
	 
	 
	 
	 
	 
}
AMM::Capability::Scenario::Scenario()
{
}

AMM::Capability::Scenario::~Scenario()
{
}

AMM::Capability::Scenario::Scenario(const Scenario &x)
{
    m_id = x.m_id;
}

AMM::Capability::Scenario::Scenario(Scenario &&x)
{
    m_id = std::move(x.m_id);
}

AMM::Capability::Scenario& AMM::Capability::Scenario::operator=(const Scenario &x)
{
    m_id = x.m_id;
    
    return *this;
}

AMM::Capability::Scenario& AMM::Capability::Scenario::operator=(Scenario &&x)
{
    m_id = std::move(x.m_id);
    
    return *this;
}

size_t AMM::Capability::Scenario::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t AMM::Capability::Scenario::getCdrSerializedSize(const AMM::Capability::Scenario& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.id().size() + 1;

    return current_alignment - initial_alignment;
}

void AMM::Capability::Scenario::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_id;
}

void AMM::Capability::Scenario::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_id;
}

size_t AMM::Capability::Scenario::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool AMM::Capability::Scenario::isKeyDefined()
{
    return false;
}

void AMM::Capability::Scenario::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}
AMM::Capability::Status::Status()
{



    m_status_value = AMM::Capability::OPERATIONAL;

}

AMM::Capability::Status::~Status()
{
}

AMM::Capability::Status::Status(const Status &x)
{
    m_module_id = x.m_module_id;
    m_module_name = x.m_module_name;
    m_capability = x.m_capability;
    m_status_value = x.m_status_value;
    m_message = x.m_message;
}

AMM::Capability::Status::Status(Status &&x)
{
    m_module_id = std::move(x.m_module_id);
    m_module_name = std::move(x.m_module_name);
    m_capability = std::move(x.m_capability);
    m_status_value = x.m_status_value;
    m_message = std::move(x.m_message);
}

AMM::Capability::Status& AMM::Capability::Status::operator=(const Status &x)
{
    m_module_id = x.m_module_id;
    m_module_name = x.m_module_name;
    m_capability = x.m_capability;
    m_status_value = x.m_status_value;
    m_message = x.m_message;
    
    return *this;
}

AMM::Capability::Status& AMM::Capability::Status::operator=(Status &&x)
{
    m_module_id = std::move(x.m_module_id);
    m_module_name = std::move(x.m_module_name);
    m_capability = std::move(x.m_capability);
    m_status_value = x.m_status_value;
    m_message = std::move(x.m_message);
    
    return *this;
}

size_t AMM::Capability::Status::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;
    }

    return current_alignment - initial_alignment;
}

size_t AMM::Capability::Status::getCdrSerializedSize(const AMM::Capability::Status& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.module_id().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.module_name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.capability().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.message().size(); ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.message().at(a).size() + 1;
    }

    return current_alignment - initial_alignment;
}

void AMM::Capability::Status::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_module_id;
    scdr << m_module_name;
    scdr << m_capability;
    scdr << (uint32_t)m_status_value;
    scdr << m_message;
}

void AMM::Capability::Status::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_module_id;
    dcdr >> m_module_name;
    dcdr >> m_capability;
    dcdr >> (uint32_t&)m_status_value;
    dcdr >> m_message;
}

size_t AMM::Capability::Status::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            






    return current_align;
}

bool AMM::Capability::Status::isKeyDefined()
{
    return false;
}

void AMM::Capability::Status::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
	 
	 
}

