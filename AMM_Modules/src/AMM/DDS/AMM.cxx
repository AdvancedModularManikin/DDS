// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file AMM.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "AMM.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

AMM::FMA_Location::FMA_Location()
{
    m_id = 0;


}

AMM::FMA_Location::~FMA_Location()
{


}

AMM::FMA_Location::FMA_Location(const FMA_Location &x)
{
    m_id = x.m_id;
    m_description = x.m_description;
}

AMM::FMA_Location::FMA_Location(FMA_Location &&x)
{
    m_id = x.m_id;
    m_description = std::move(x.m_description);
}

AMM::FMA_Location& AMM::FMA_Location::operator=(const FMA_Location &x)
{

    m_id = x.m_id;
    m_description = x.m_description;

    return *this;
}

AMM::FMA_Location& AMM::FMA_Location::operator=(FMA_Location &&x)
{

    m_id = x.m_id;
    m_description = std::move(x.m_description);

    return *this;
}

size_t AMM::FMA_Location::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::FMA_Location::getCdrSerializedSize(const AMM::FMA_Location& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.description().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::FMA_Location::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_id;
    scdr << m_description;
}

void AMM::FMA_Location::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_id;
    dcdr >> m_description;
}

/*!
 * @brief This function sets a value in member id
 * @param _id New value for member id
 */
void AMM::FMA_Location::id(int32_t _id)
{
m_id = _id;
}

/*!
 * @brief This function returns the value of member id
 * @return Value of member id
 */
int32_t AMM::FMA_Location::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
int32_t& AMM::FMA_Location::id()
{
    return m_id;
}
/*!
 * @brief This function copies the value in member description
 * @param _description New value to be copied in member description
 */
void AMM::FMA_Location::description(const std::string &_description)
{
m_description = _description;
}

/*!
 * @brief This function moves the value in member description
 * @param _description New value to be moved in member description
 */
void AMM::FMA_Location::description(std::string &&_description)
{
m_description = std::move(_description);
}

/*!
 * @brief This function returns a constant reference to member description
 * @return Constant reference to member description
 */
const std::string& AMM::FMA_Location::description() const
{
    return m_description;
}

/*!
 * @brief This function returns a reference to member description
 * @return Reference to member description
 */
std::string& AMM::FMA_Location::description()
{
    return m_description;
}

size_t AMM::FMA_Location::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;





    return current_align;
}

bool AMM::FMA_Location::isKeyDefined()
{
   return false;
}

void AMM::FMA_Location::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}

AMM::UUID::UUID()
{
    m_UUID_MSB = 0;
    m_UUID_LSB = 0;

}

AMM::UUID::~UUID()
{


}

AMM::UUID::UUID(const UUID &x)
{
    m_UUID_MSB = x.m_UUID_MSB;
    m_UUID_LSB = x.m_UUID_LSB;
}

AMM::UUID::UUID(UUID &&x)
{
    m_UUID_MSB = x.m_UUID_MSB;
    m_UUID_LSB = x.m_UUID_LSB;
}

AMM::UUID& AMM::UUID::operator=(const UUID &x)
{

    m_UUID_MSB = x.m_UUID_MSB;
    m_UUID_LSB = x.m_UUID_LSB;

    return *this;
}

AMM::UUID& AMM::UUID::operator=(UUID &&x)
{

    m_UUID_MSB = x.m_UUID_MSB;
    m_UUID_LSB = x.m_UUID_LSB;

    return *this;
}

size_t AMM::UUID::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t AMM::UUID::getCdrSerializedSize(const AMM::UUID& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void AMM::UUID::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_UUID_MSB;
    scdr << m_UUID_LSB;
}

void AMM::UUID::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_UUID_MSB;
    dcdr >> m_UUID_LSB;
}

/*!
 * @brief This function sets a value in member UUID_MSB
 * @param _UUID_MSB New value for member UUID_MSB
 */
void AMM::UUID::UUID_MSB(int64_t _UUID_MSB)
{
m_UUID_MSB = _UUID_MSB;
}

/*!
 * @brief This function returns the value of member UUID_MSB
 * @return Value of member UUID_MSB
 */
int64_t AMM::UUID::UUID_MSB() const
{
    return m_UUID_MSB;
}

/*!
 * @brief This function returns a reference to member UUID_MSB
 * @return Reference to member UUID_MSB
 */
int64_t& AMM::UUID::UUID_MSB()
{
    return m_UUID_MSB;
}
/*!
 * @brief This function sets a value in member UUID_LSB
 * @param _UUID_LSB New value for member UUID_LSB
 */
void AMM::UUID::UUID_LSB(int64_t _UUID_LSB)
{
m_UUID_LSB = _UUID_LSB;
}

/*!
 * @brief This function returns the value of member UUID_LSB
 * @return Value of member UUID_LSB
 */
int64_t AMM::UUID::UUID_LSB() const
{
    return m_UUID_LSB;
}

/*!
 * @brief This function returns a reference to member UUID_LSB
 * @return Reference to member UUID_LSB
 */
int64_t& AMM::UUID::UUID_LSB()
{
    return m_UUID_LSB;
}

size_t AMM::UUID::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;





    return current_align;
}

bool AMM::UUID::isKeyDefined()
{
   return false;
}

void AMM::UUID::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}

AMM::Event::Fragment::Fragment()
{

    m_timestamp = 0.0;





}

AMM::Event::Fragment::~Fragment()
{






}

AMM::Event::Fragment::Fragment(const Fragment &x)
{
    m_id = x.m_id;
    m_timestamp = x.m_timestamp;
    m_location = x.m_location;
    m_learner_id = x.m_learner_id;
    m_fragment_type = x.m_fragment_type;
    m_payload = x.m_payload;
}

AMM::Event::Fragment::Fragment(Fragment &&x)
{
    m_id = std::move(x.m_id);
    m_timestamp = x.m_timestamp;
    m_location = std::move(x.m_location);
    m_learner_id = std::move(x.m_learner_id);
    m_fragment_type = std::move(x.m_fragment_type);
    m_payload = std::move(x.m_payload);
}

AMM::Event::Fragment& AMM::Event::Fragment::operator=(const Fragment &x)
{

    m_id = x.m_id;
    m_timestamp = x.m_timestamp;
    m_location = x.m_location;
    m_learner_id = x.m_learner_id;
    m_fragment_type = x.m_fragment_type;
    m_payload = x.m_payload;

    return *this;
}

AMM::Event::Fragment& AMM::Event::Fragment::operator=(Fragment &&x)
{

    m_id = std::move(x.m_id);
    m_timestamp = x.m_timestamp;
    m_location = std::move(x.m_location);
    m_learner_id = std::move(x.m_learner_id);
    m_fragment_type = std::move(x.m_fragment_type);
    m_payload = std::move(x.m_payload);

    return *this;
}

size_t AMM::Event::Fragment::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Event::Fragment::getCdrSerializedSize(const AMM::Event::Fragment& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += AMM::UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.learner_id().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.fragment_type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.payload().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Event::Fragment::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_id;
    scdr << m_timestamp;
    scdr << m_location;
    scdr << m_learner_id;
    scdr << m_fragment_type;
    scdr << m_payload;
}

void AMM::Event::Fragment::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_id;
    dcdr >> m_timestamp;
    dcdr >> m_location;
    dcdr >> m_learner_id;
    dcdr >> m_fragment_type;
    dcdr >> m_payload;
}

/*!
 * @brief This function copies the value in member id
 * @param _id New value to be copied in member id
 */
void AMM::Event::Fragment::id(const AMM::UUID &_id)
{
m_id = _id;
}

/*!
 * @brief This function moves the value in member id
 * @param _id New value to be moved in member id
 */
void AMM::Event::Fragment::id(AMM::UUID &&_id)
{
m_id = std::move(_id);
}

/*!
 * @brief This function returns a constant reference to member id
 * @return Constant reference to member id
 */
const AMM::UUID& AMM::Event::Fragment::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
AMM::UUID& AMM::Event::Fragment::id()
{
    return m_id;
}
/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
void AMM::Event::Fragment::timestamp(float _timestamp)
{
m_timestamp = _timestamp;
}

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
float AMM::Event::Fragment::timestamp() const
{
    return m_timestamp;
}

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
float& AMM::Event::Fragment::timestamp()
{
    return m_timestamp;
}
/*!
 * @brief This function copies the value in member location
 * @param _location New value to be copied in member location
 */
void AMM::Event::Fragment::location(const AMM::FMA_Location &_location)
{
m_location = _location;
}

/*!
 * @brief This function moves the value in member location
 * @param _location New value to be moved in member location
 */
void AMM::Event::Fragment::location(AMM::FMA_Location &&_location)
{
m_location = std::move(_location);
}

/*!
 * @brief This function returns a constant reference to member location
 * @return Constant reference to member location
 */
const AMM::FMA_Location& AMM::Event::Fragment::location() const
{
    return m_location;
}

/*!
 * @brief This function returns a reference to member location
 * @return Reference to member location
 */
AMM::FMA_Location& AMM::Event::Fragment::location()
{
    return m_location;
}
/*!
 * @brief This function copies the value in member learner_id
 * @param _learner_id New value to be copied in member learner_id
 */
void AMM::Event::Fragment::learner_id(const std::string &_learner_id)
{
m_learner_id = _learner_id;
}

/*!
 * @brief This function moves the value in member learner_id
 * @param _learner_id New value to be moved in member learner_id
 */
void AMM::Event::Fragment::learner_id(std::string &&_learner_id)
{
m_learner_id = std::move(_learner_id);
}

/*!
 * @brief This function returns a constant reference to member learner_id
 * @return Constant reference to member learner_id
 */
const std::string& AMM::Event::Fragment::learner_id() const
{
    return m_learner_id;
}

/*!
 * @brief This function returns a reference to member learner_id
 * @return Reference to member learner_id
 */
std::string& AMM::Event::Fragment::learner_id()
{
    return m_learner_id;
}
/*!
 * @brief This function copies the value in member fragment_type
 * @param _fragment_type New value to be copied in member fragment_type
 */
void AMM::Event::Fragment::fragment_type(const std::string &_fragment_type)
{
m_fragment_type = _fragment_type;
}

/*!
 * @brief This function moves the value in member fragment_type
 * @param _fragment_type New value to be moved in member fragment_type
 */
void AMM::Event::Fragment::fragment_type(std::string &&_fragment_type)
{
m_fragment_type = std::move(_fragment_type);
}

/*!
 * @brief This function returns a constant reference to member fragment_type
 * @return Constant reference to member fragment_type
 */
const std::string& AMM::Event::Fragment::fragment_type() const
{
    return m_fragment_type;
}

/*!
 * @brief This function returns a reference to member fragment_type
 * @return Reference to member fragment_type
 */
std::string& AMM::Event::Fragment::fragment_type()
{
    return m_fragment_type;
}
/*!
 * @brief This function copies the value in member payload
 * @param _payload New value to be copied in member payload
 */
void AMM::Event::Fragment::payload(const std::string &_payload)
{
m_payload = _payload;
}

/*!
 * @brief This function moves the value in member payload
 * @param _payload New value to be moved in member payload
 */
void AMM::Event::Fragment::payload(std::string &&_payload)
{
m_payload = std::move(_payload);
}

/*!
 * @brief This function returns a constant reference to member payload
 * @return Constant reference to member payload
 */
const std::string& AMM::Event::Fragment::payload() const
{
    return m_payload;
}

/*!
 * @brief This function returns a reference to member payload
 * @return Reference to member payload
 */
std::string& AMM::Event::Fragment::payload()
{
    return m_payload;
}

size_t AMM::Event::Fragment::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;


     current_align += AMM::UUID::getMaxCdrSerializedSize(current_align); 






    return current_align;
}

bool AMM::Event::Fragment::isKeyDefined()
{
   return true;
}

void AMM::Event::Fragment::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_id;  
	 
	 
	 
	 
	 
}

AMM::Event::FragmentAmendmentRequest::FragmentAmendmentRequest()
{


    m_timestamp = 0.0;






}

AMM::Event::FragmentAmendmentRequest::~FragmentAmendmentRequest()
{








}

AMM::Event::FragmentAmendmentRequest::FragmentAmendmentRequest(const FragmentAmendmentRequest &x)
{
    m_id = x.m_id;
    m_fragment_id = x.m_fragment_id;
    m_timestamp = x.m_timestamp;
    m_status = x.m_status;
    m_location = x.m_location;
    m_learner_id = x.m_learner_id;
    m_fragment_type = x.m_fragment_type;
    m_payload = x.m_payload;
}

AMM::Event::FragmentAmendmentRequest::FragmentAmendmentRequest(FragmentAmendmentRequest &&x)
{
    m_id = std::move(x.m_id);
    m_fragment_id = std::move(x.m_fragment_id);
    m_timestamp = x.m_timestamp;
    m_status = std::move(x.m_status);
    m_location = std::move(x.m_location);
    m_learner_id = std::move(x.m_learner_id);
    m_fragment_type = std::move(x.m_fragment_type);
    m_payload = std::move(x.m_payload);
}

AMM::Event::FragmentAmendmentRequest& AMM::Event::FragmentAmendmentRequest::operator=(const FragmentAmendmentRequest &x)
{

    m_id = x.m_id;
    m_fragment_id = x.m_fragment_id;
    m_timestamp = x.m_timestamp;
    m_status = x.m_status;
    m_location = x.m_location;
    m_learner_id = x.m_learner_id;
    m_fragment_type = x.m_fragment_type;
    m_payload = x.m_payload;

    return *this;
}

AMM::Event::FragmentAmendmentRequest& AMM::Event::FragmentAmendmentRequest::operator=(FragmentAmendmentRequest &&x)
{

    m_id = std::move(x.m_id);
    m_fragment_id = std::move(x.m_fragment_id);
    m_timestamp = x.m_timestamp;
    m_status = std::move(x.m_status);
    m_location = std::move(x.m_location);
    m_learner_id = std::move(x.m_learner_id);
    m_fragment_type = std::move(x.m_fragment_type);
    m_payload = std::move(x.m_payload);

    return *this;
}

size_t AMM::Event::FragmentAmendmentRequest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += AMM::FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Event::FragmentAmendmentRequest::getCdrSerializedSize(const AMM::Event::FragmentAmendmentRequest& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += AMM::UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += AMM::UUID::getCdrSerializedSize(data.fragment_id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.status().size() + 1;

    current_alignment += AMM::FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.learner_id().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.fragment_type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.payload().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Event::FragmentAmendmentRequest::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_id;
    scdr << m_fragment_id;
    scdr << m_timestamp;
    scdr << m_status;
    scdr << m_location;
    scdr << m_learner_id;
    scdr << m_fragment_type;
    scdr << m_payload;
}

void AMM::Event::FragmentAmendmentRequest::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_id;
    dcdr >> m_fragment_id;
    dcdr >> m_timestamp;
    dcdr >> m_status;
    dcdr >> m_location;
    dcdr >> m_learner_id;
    dcdr >> m_fragment_type;
    dcdr >> m_payload;
}

/*!
 * @brief This function copies the value in member id
 * @param _id New value to be copied in member id
 */
void AMM::Event::FragmentAmendmentRequest::id(const AMM::UUID &_id)
{
m_id = _id;
}

/*!
 * @brief This function moves the value in member id
 * @param _id New value to be moved in member id
 */
void AMM::Event::FragmentAmendmentRequest::id(AMM::UUID &&_id)
{
m_id = std::move(_id);
}

/*!
 * @brief This function returns a constant reference to member id
 * @return Constant reference to member id
 */
const AMM::UUID& AMM::Event::FragmentAmendmentRequest::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
AMM::UUID& AMM::Event::FragmentAmendmentRequest::id()
{
    return m_id;
}
/*!
 * @brief This function copies the value in member fragment_id
 * @param _fragment_id New value to be copied in member fragment_id
 */
void AMM::Event::FragmentAmendmentRequest::fragment_id(const AMM::UUID &_fragment_id)
{
m_fragment_id = _fragment_id;
}

/*!
 * @brief This function moves the value in member fragment_id
 * @param _fragment_id New value to be moved in member fragment_id
 */
void AMM::Event::FragmentAmendmentRequest::fragment_id(AMM::UUID &&_fragment_id)
{
m_fragment_id = std::move(_fragment_id);
}

/*!
 * @brief This function returns a constant reference to member fragment_id
 * @return Constant reference to member fragment_id
 */
const AMM::UUID& AMM::Event::FragmentAmendmentRequest::fragment_id() const
{
    return m_fragment_id;
}

/*!
 * @brief This function returns a reference to member fragment_id
 * @return Reference to member fragment_id
 */
AMM::UUID& AMM::Event::FragmentAmendmentRequest::fragment_id()
{
    return m_fragment_id;
}
/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
void AMM::Event::FragmentAmendmentRequest::timestamp(float _timestamp)
{
m_timestamp = _timestamp;
}

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
float AMM::Event::FragmentAmendmentRequest::timestamp() const
{
    return m_timestamp;
}

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
float& AMM::Event::FragmentAmendmentRequest::timestamp()
{
    return m_timestamp;
}
/*!
 * @brief This function copies the value in member status
 * @param _status New value to be copied in member status
 */
void AMM::Event::FragmentAmendmentRequest::status(const std::string &_status)
{
m_status = _status;
}

/*!
 * @brief This function moves the value in member status
 * @param _status New value to be moved in member status
 */
void AMM::Event::FragmentAmendmentRequest::status(std::string &&_status)
{
m_status = std::move(_status);
}

/*!
 * @brief This function returns a constant reference to member status
 * @return Constant reference to member status
 */
const std::string& AMM::Event::FragmentAmendmentRequest::status() const
{
    return m_status;
}

/*!
 * @brief This function returns a reference to member status
 * @return Reference to member status
 */
std::string& AMM::Event::FragmentAmendmentRequest::status()
{
    return m_status;
}
/*!
 * @brief This function copies the value in member location
 * @param _location New value to be copied in member location
 */
void AMM::Event::FragmentAmendmentRequest::location(const AMM::FMA_Location &_location)
{
m_location = _location;
}

/*!
 * @brief This function moves the value in member location
 * @param _location New value to be moved in member location
 */
void AMM::Event::FragmentAmendmentRequest::location(AMM::FMA_Location &&_location)
{
m_location = std::move(_location);
}

/*!
 * @brief This function returns a constant reference to member location
 * @return Constant reference to member location
 */
const AMM::FMA_Location& AMM::Event::FragmentAmendmentRequest::location() const
{
    return m_location;
}

/*!
 * @brief This function returns a reference to member location
 * @return Reference to member location
 */
AMM::FMA_Location& AMM::Event::FragmentAmendmentRequest::location()
{
    return m_location;
}
/*!
 * @brief This function copies the value in member learner_id
 * @param _learner_id New value to be copied in member learner_id
 */
void AMM::Event::FragmentAmendmentRequest::learner_id(const std::string &_learner_id)
{
m_learner_id = _learner_id;
}

/*!
 * @brief This function moves the value in member learner_id
 * @param _learner_id New value to be moved in member learner_id
 */
void AMM::Event::FragmentAmendmentRequest::learner_id(std::string &&_learner_id)
{
m_learner_id = std::move(_learner_id);
}

/*!
 * @brief This function returns a constant reference to member learner_id
 * @return Constant reference to member learner_id
 */
const std::string& AMM::Event::FragmentAmendmentRequest::learner_id() const
{
    return m_learner_id;
}

/*!
 * @brief This function returns a reference to member learner_id
 * @return Reference to member learner_id
 */
std::string& AMM::Event::FragmentAmendmentRequest::learner_id()
{
    return m_learner_id;
}
/*!
 * @brief This function copies the value in member fragment_type
 * @param _fragment_type New value to be copied in member fragment_type
 */
void AMM::Event::FragmentAmendmentRequest::fragment_type(const std::string &_fragment_type)
{
m_fragment_type = _fragment_type;
}

/*!
 * @brief This function moves the value in member fragment_type
 * @param _fragment_type New value to be moved in member fragment_type
 */
void AMM::Event::FragmentAmendmentRequest::fragment_type(std::string &&_fragment_type)
{
m_fragment_type = std::move(_fragment_type);
}

/*!
 * @brief This function returns a constant reference to member fragment_type
 * @return Constant reference to member fragment_type
 */
const std::string& AMM::Event::FragmentAmendmentRequest::fragment_type() const
{
    return m_fragment_type;
}

/*!
 * @brief This function returns a reference to member fragment_type
 * @return Reference to member fragment_type
 */
std::string& AMM::Event::FragmentAmendmentRequest::fragment_type()
{
    return m_fragment_type;
}
/*!
 * @brief This function copies the value in member payload
 * @param _payload New value to be copied in member payload
 */
void AMM::Event::FragmentAmendmentRequest::payload(const std::string &_payload)
{
m_payload = _payload;
}

/*!
 * @brief This function moves the value in member payload
 * @param _payload New value to be moved in member payload
 */
void AMM::Event::FragmentAmendmentRequest::payload(std::string &&_payload)
{
m_payload = std::move(_payload);
}

/*!
 * @brief This function returns a constant reference to member payload
 * @return Constant reference to member payload
 */
const std::string& AMM::Event::FragmentAmendmentRequest::payload() const
{
    return m_payload;
}

/*!
 * @brief This function returns a reference to member payload
 * @return Reference to member payload
 */
std::string& AMM::Event::FragmentAmendmentRequest::payload()
{
    return m_payload;
}

size_t AMM::Event::FragmentAmendmentRequest::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;



     current_align += AMM::UUID::getMaxCdrSerializedSize(current_align); 







    return current_align;
}

bool AMM::Event::FragmentAmendmentRequest::isKeyDefined()
{
   return true;
}

void AMM::Event::FragmentAmendmentRequest::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 scdr << m_fragment_id;  
	 
	 
	 
	 
	 
	 
}

AMM::Event::Record::Record()
{

    m_timestamp = 0.0;





}

AMM::Event::Record::~Record()
{






}

AMM::Event::Record::Record(const Record &x)
{
    m_id = x.m_id;
    m_timestamp = x.m_timestamp;
    m_location = x.m_location;
    m_learner_id = x.m_learner_id;
    m_record_type = x.m_record_type;
    m_payload = x.m_payload;
}

AMM::Event::Record::Record(Record &&x)
{
    m_id = std::move(x.m_id);
    m_timestamp = x.m_timestamp;
    m_location = std::move(x.m_location);
    m_learner_id = std::move(x.m_learner_id);
    m_record_type = std::move(x.m_record_type);
    m_payload = std::move(x.m_payload);
}

AMM::Event::Record& AMM::Event::Record::operator=(const Record &x)
{

    m_id = x.m_id;
    m_timestamp = x.m_timestamp;
    m_location = x.m_location;
    m_learner_id = x.m_learner_id;
    m_record_type = x.m_record_type;
    m_payload = x.m_payload;

    return *this;
}

AMM::Event::Record& AMM::Event::Record::operator=(Record &&x)
{

    m_id = std::move(x.m_id);
    m_timestamp = x.m_timestamp;
    m_location = std::move(x.m_location);
    m_learner_id = std::move(x.m_learner_id);
    m_record_type = std::move(x.m_record_type);
    m_payload = std::move(x.m_payload);

    return *this;
}

size_t AMM::Event::Record::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Event::Record::getCdrSerializedSize(const AMM::Event::Record& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += AMM::UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += AMM::FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.learner_id().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.record_type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.payload().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Event::Record::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_id;
    scdr << m_timestamp;
    scdr << m_location;
    scdr << m_learner_id;
    scdr << m_record_type;
    scdr << m_payload;
}

void AMM::Event::Record::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_id;
    dcdr >> m_timestamp;
    dcdr >> m_location;
    dcdr >> m_learner_id;
    dcdr >> m_record_type;
    dcdr >> m_payload;
}

/*!
 * @brief This function copies the value in member id
 * @param _id New value to be copied in member id
 */
void AMM::Event::Record::id(const AMM::UUID &_id)
{
m_id = _id;
}

/*!
 * @brief This function moves the value in member id
 * @param _id New value to be moved in member id
 */
void AMM::Event::Record::id(AMM::UUID &&_id)
{
m_id = std::move(_id);
}

/*!
 * @brief This function returns a constant reference to member id
 * @return Constant reference to member id
 */
const AMM::UUID& AMM::Event::Record::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
AMM::UUID& AMM::Event::Record::id()
{
    return m_id;
}
/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
void AMM::Event::Record::timestamp(float _timestamp)
{
m_timestamp = _timestamp;
}

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
float AMM::Event::Record::timestamp() const
{
    return m_timestamp;
}

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
float& AMM::Event::Record::timestamp()
{
    return m_timestamp;
}
/*!
 * @brief This function copies the value in member location
 * @param _location New value to be copied in member location
 */
void AMM::Event::Record::location(const AMM::FMA_Location &_location)
{
m_location = _location;
}

/*!
 * @brief This function moves the value in member location
 * @param _location New value to be moved in member location
 */
void AMM::Event::Record::location(AMM::FMA_Location &&_location)
{
m_location = std::move(_location);
}

/*!
 * @brief This function returns a constant reference to member location
 * @return Constant reference to member location
 */
const AMM::FMA_Location& AMM::Event::Record::location() const
{
    return m_location;
}

/*!
 * @brief This function returns a reference to member location
 * @return Reference to member location
 */
AMM::FMA_Location& AMM::Event::Record::location()
{
    return m_location;
}
/*!
 * @brief This function copies the value in member learner_id
 * @param _learner_id New value to be copied in member learner_id
 */
void AMM::Event::Record::learner_id(const std::string &_learner_id)
{
m_learner_id = _learner_id;
}

/*!
 * @brief This function moves the value in member learner_id
 * @param _learner_id New value to be moved in member learner_id
 */
void AMM::Event::Record::learner_id(std::string &&_learner_id)
{
m_learner_id = std::move(_learner_id);
}

/*!
 * @brief This function returns a constant reference to member learner_id
 * @return Constant reference to member learner_id
 */
const std::string& AMM::Event::Record::learner_id() const
{
    return m_learner_id;
}

/*!
 * @brief This function returns a reference to member learner_id
 * @return Reference to member learner_id
 */
std::string& AMM::Event::Record::learner_id()
{
    return m_learner_id;
}
/*!
 * @brief This function copies the value in member record_type
 * @param _record_type New value to be copied in member record_type
 */
void AMM::Event::Record::record_type(const std::string &_record_type)
{
m_record_type = _record_type;
}

/*!
 * @brief This function moves the value in member record_type
 * @param _record_type New value to be moved in member record_type
 */
void AMM::Event::Record::record_type(std::string &&_record_type)
{
m_record_type = std::move(_record_type);
}

/*!
 * @brief This function returns a constant reference to member record_type
 * @return Constant reference to member record_type
 */
const std::string& AMM::Event::Record::record_type() const
{
    return m_record_type;
}

/*!
 * @brief This function returns a reference to member record_type
 * @return Reference to member record_type
 */
std::string& AMM::Event::Record::record_type()
{
    return m_record_type;
}
/*!
 * @brief This function copies the value in member payload
 * @param _payload New value to be copied in member payload
 */
void AMM::Event::Record::payload(const std::string &_payload)
{
m_payload = _payload;
}

/*!
 * @brief This function moves the value in member payload
 * @param _payload New value to be moved in member payload
 */
void AMM::Event::Record::payload(std::string &&_payload)
{
m_payload = std::move(_payload);
}

/*!
 * @brief This function returns a constant reference to member payload
 * @return Constant reference to member payload
 */
const std::string& AMM::Event::Record::payload() const
{
    return m_payload;
}

/*!
 * @brief This function returns a reference to member payload
 * @return Reference to member payload
 */
std::string& AMM::Event::Record::payload()
{
    return m_payload;
}

size_t AMM::Event::Record::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;


     current_align += AMM::UUID::getMaxCdrSerializedSize(current_align); 






    return current_align;
}

bool AMM::Event::Record::isKeyDefined()
{
   return true;
}

void AMM::Event::Record::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_id;  
	 
	 
	 
	 
	 
}


AMM::Environment::Settings::Settings()
{

}

AMM::Environment::Settings::~Settings()
{
}

AMM::Environment::Settings::Settings(const Settings &x)
{
    m_description = x.m_description;
}

AMM::Environment::Settings::Settings(Settings &&x)
{
    m_description = std::move(x.m_description);
}

AMM::Environment::Settings& AMM::Environment::Settings::operator=(const Settings &x)
{

    m_description = x.m_description;

    return *this;
}

AMM::Environment::Settings& AMM::Environment::Settings::operator=(Settings &&x)
{

    m_description = std::move(x.m_description);

    return *this;
}

size_t AMM::Environment::Settings::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t AMM::Environment::Settings::getCdrSerializedSize(const AMM::Environment::Settings& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.description().size() + 1;

    return current_alignment - initial_alignment;
}

void AMM::Environment::Settings::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_description;
}

void AMM::Environment::Settings::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_description;
}

/*!
 * @brief This function copies the value in member description
 * @param _description New value to be copied in member description
 */
void AMM::Environment::Settings::description(const std::string &_description)
{
m_description = _description;
}

/*!
 * @brief This function moves the value in member description
 * @param _description New value to be moved in member description
 */
void AMM::Environment::Settings::description(std::string &&_description)
{
m_description = std::move(_description);
}

/*!
 * @brief This function returns a constant reference to member description
 * @return Constant reference to member description
 */
const std::string& AMM::Environment::Settings::description() const
{
    return m_description;
}

/*!
 * @brief This function returns a reference to member description
 * @return Reference to member description
 */
std::string& AMM::Environment::Settings::description()
{
    return m_description;
}

size_t AMM::Environment::Settings::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;



    return current_align;
}

bool AMM::Environment::Settings::isKeyDefined()
{
   return false;
}

void AMM::Environment::Settings::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
}


AMM::Simulation::Tick::Tick()
{
    m_frame = 0;
    m_time = 0.0;

}

AMM::Simulation::Tick::~Tick()
{


}

AMM::Simulation::Tick::Tick(const Tick &x)
{
    m_frame = x.m_frame;
    m_time = x.m_time;
}

AMM::Simulation::Tick::Tick(Tick &&x)
{
    m_frame = x.m_frame;
    m_time = x.m_time;
}

AMM::Simulation::Tick& AMM::Simulation::Tick::operator=(const Tick &x)
{

    m_frame = x.m_frame;
    m_time = x.m_time;

    return *this;
}

AMM::Simulation::Tick& AMM::Simulation::Tick::operator=(Tick &&x)
{

    m_frame = x.m_frame;
    m_time = x.m_time;

    return *this;
}

size_t AMM::Simulation::Tick::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

size_t AMM::Simulation::Tick::getCdrSerializedSize(const AMM::Simulation::Tick& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);



    return current_alignment - initial_alignment;
}

void AMM::Simulation::Tick::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_frame;
    scdr << m_time;
}

void AMM::Simulation::Tick::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_frame;
    dcdr >> m_time;
}

/*!
 * @brief This function sets a value in member frame
 * @param _frame New value for member frame
 */
void AMM::Simulation::Tick::frame(int64_t _frame)
{
m_frame = _frame;
}

/*!
 * @brief This function returns the value of member frame
 * @return Value of member frame
 */
int64_t AMM::Simulation::Tick::frame() const
{
    return m_frame;
}

/*!
 * @brief This function returns a reference to member frame
 * @return Reference to member frame
 */
int64_t& AMM::Simulation::Tick::frame()
{
    return m_frame;
}
/*!
 * @brief This function sets a value in member time
 * @param _time New value for member time
 */
void AMM::Simulation::Tick::time(float _time)
{
m_time = _time;
}

/*!
 * @brief This function returns the value of member time
 * @return Value of member time
 */
float AMM::Simulation::Tick::time() const
{
    return m_time;
}

/*!
 * @brief This function returns a reference to member time
 * @return Reference to member time
 */
float& AMM::Simulation::Tick::time()
{
    return m_time;
}

size_t AMM::Simulation::Tick::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;


     current_align += 8 + eprosima::fastcdr::Cdr::alignment(current_align, 8);

     


    return current_align;
}

bool AMM::Simulation::Tick::isKeyDefined()
{
   return true;
}

void AMM::Simulation::Tick::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_frame;  
	 
}


AMM::InstrumentData::InstrumentData()
{



}

AMM::InstrumentData::~InstrumentData()
{


}

AMM::InstrumentData::InstrumentData(const InstrumentData &x)
{
    m_instrument = x.m_instrument;
    m_payload = x.m_payload;
}

AMM::InstrumentData::InstrumentData(InstrumentData &&x)
{
    m_instrument = std::move(x.m_instrument);
    m_payload = std::move(x.m_payload);
}

AMM::InstrumentData& AMM::InstrumentData::operator=(const InstrumentData &x)
{

    m_instrument = x.m_instrument;
    m_payload = x.m_payload;

    return *this;
}

AMM::InstrumentData& AMM::InstrumentData::operator=(InstrumentData &&x)
{

    m_instrument = std::move(x.m_instrument);
    m_payload = std::move(x.m_payload);

    return *this;
}

size_t AMM::InstrumentData::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::InstrumentData::getCdrSerializedSize(const AMM::InstrumentData& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.instrument().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.payload().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::InstrumentData::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_instrument;
    scdr << m_payload;
}

void AMM::InstrumentData::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_instrument;
    dcdr >> m_payload;
}

/*!
 * @brief This function copies the value in member instrument
 * @param _instrument New value to be copied in member instrument
 */
void AMM::InstrumentData::instrument(const std::string &_instrument)
{
m_instrument = _instrument;
}

/*!
 * @brief This function moves the value in member instrument
 * @param _instrument New value to be moved in member instrument
 */
void AMM::InstrumentData::instrument(std::string &&_instrument)
{
m_instrument = std::move(_instrument);
}

/*!
 * @brief This function returns a constant reference to member instrument
 * @return Constant reference to member instrument
 */
const std::string& AMM::InstrumentData::instrument() const
{
    return m_instrument;
}

/*!
 * @brief This function returns a reference to member instrument
 * @return Reference to member instrument
 */
std::string& AMM::InstrumentData::instrument()
{
    return m_instrument;
}
/*!
 * @brief This function copies the value in member payload
 * @param _payload New value to be copied in member payload
 */
void AMM::InstrumentData::payload(const std::string &_payload)
{
m_payload = _payload;
}

/*!
 * @brief This function moves the value in member payload
 * @param _payload New value to be moved in member payload
 */
void AMM::InstrumentData::payload(std::string &&_payload)
{
m_payload = std::move(_payload);
}

/*!
 * @brief This function returns a constant reference to member payload
 * @return Constant reference to member payload
 */
const std::string& AMM::InstrumentData::payload() const
{
    return m_payload;
}

/*!
 * @brief This function returns a reference to member payload
 * @return Reference to member payload
 */
std::string& AMM::InstrumentData::payload()
{
    return m_payload;
}

size_t AMM::InstrumentData::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;





    return current_align;
}

bool AMM::InstrumentData::isKeyDefined()
{
   return false;
}

void AMM::InstrumentData::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}



AMM::Physiology::Command::Command()
{
    m_type = AMM::Physiology::PainCommand;


}

AMM::Physiology::Command::~Command()
{


}

AMM::Physiology::Command::Command(const Command &x)
{
    m_type = x.m_type;
    m_payload = x.m_payload;
}

AMM::Physiology::Command::Command(Command &&x)
{
    m_type = x.m_type;
    m_payload = std::move(x.m_payload);
}

AMM::Physiology::Command& AMM::Physiology::Command::operator=(const Command &x)
{

    m_type = x.m_type;
    m_payload = x.m_payload;

    return *this;
}

AMM::Physiology::Command& AMM::Physiology::Command::operator=(Command &&x)
{

    m_type = x.m_type;
    m_payload = std::move(x.m_payload);

    return *this;
}

size_t AMM::Physiology::Command::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

size_t AMM::Physiology::Command::getCdrSerializedSize(const AMM::Physiology::Command& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += (data.payload().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);




    return current_alignment - initial_alignment;
}

void AMM::Physiology::Command::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << (uint32_t)m_type;
    scdr << m_payload;
}

void AMM::Physiology::Command::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_type = (AMM::Physiology::CMD)enum_value;
    }

    dcdr >> m_payload;
}

/*!
 * @brief This function sets a value in member type
 * @param _type New value for member type
 */
void AMM::Physiology::Command::type(AMM::Physiology::CMD _type)
{
m_type = _type;
}

/*!
 * @brief This function returns the value of member type
 * @return Value of member type
 */
AMM::Physiology::CMD AMM::Physiology::Command::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
AMM::Physiology::CMD& AMM::Physiology::Command::type()
{
    return m_type;
}
/*!
 * @brief This function copies the value in member payload
 * @param _payload New value to be copied in member payload
 */
void AMM::Physiology::Command::payload(const std::vector<char> &_payload)
{
m_payload = _payload;
}

/*!
 * @brief This function moves the value in member payload
 * @param _payload New value to be moved in member payload
 */
void AMM::Physiology::Command::payload(std::vector<char> &&_payload)
{
m_payload = std::move(_payload);
}

/*!
 * @brief This function returns a constant reference to member payload
 * @return Constant reference to member payload
 */
const std::vector<char>& AMM::Physiology::Command::payload() const
{
    return m_payload;
}

/*!
 * @brief This function returns a reference to member payload
 * @return Reference to member payload
 */
std::vector<char>& AMM::Physiology::Command::payload()
{
    return m_payload;
}

size_t AMM::Physiology::Command::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;





    return current_align;
}

bool AMM::Physiology::Command::isKeyDefined()
{
   return false;
}

void AMM::Physiology::Command::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}

AMM::Physiology::PainStimulus::Data::Data()
{

    m_severity = 0.0;

}

AMM::Physiology::PainStimulus::Data::~Data()
{


}

AMM::Physiology::PainStimulus::Data::Data(const Data &x)
{
    m_location = x.m_location;
    m_severity = x.m_severity;
}

AMM::Physiology::PainStimulus::Data::Data(Data &&x)
{
    m_location = std::move(x.m_location);
    m_severity = x.m_severity;
}

AMM::Physiology::PainStimulus::Data& AMM::Physiology::PainStimulus::Data::operator=(const Data &x)
{

    m_location = x.m_location;
    m_severity = x.m_severity;

    return *this;
}

AMM::Physiology::PainStimulus::Data& AMM::Physiology::PainStimulus::Data::operator=(Data &&x)
{

    m_location = std::move(x.m_location);
    m_severity = x.m_severity;

    return *this;
}

size_t AMM::Physiology::PainStimulus::Data::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += AMM::FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t AMM::Physiology::PainStimulus::Data::getCdrSerializedSize(const AMM::Physiology::PainStimulus::Data& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += AMM::FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void AMM::Physiology::PainStimulus::Data::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_location;
    scdr << m_severity;
}

void AMM::Physiology::PainStimulus::Data::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_location;
    dcdr >> m_severity;
}

/*!
 * @brief This function copies the value in member location
 * @param _location New value to be copied in member location
 */
void AMM::Physiology::PainStimulus::Data::location(const AMM::FMA_Location &_location)
{
m_location = _location;
}

/*!
 * @brief This function moves the value in member location
 * @param _location New value to be moved in member location
 */
void AMM::Physiology::PainStimulus::Data::location(AMM::FMA_Location &&_location)
{
m_location = std::move(_location);
}

/*!
 * @brief This function returns a constant reference to member location
 * @return Constant reference to member location
 */
const AMM::FMA_Location& AMM::Physiology::PainStimulus::Data::location() const
{
    return m_location;
}

/*!
 * @brief This function returns a reference to member location
 * @return Reference to member location
 */
AMM::FMA_Location& AMM::Physiology::PainStimulus::Data::location()
{
    return m_location;
}
/*!
 * @brief This function sets a value in member severity
 * @param _severity New value for member severity
 */
void AMM::Physiology::PainStimulus::Data::severity(double _severity)
{
m_severity = _severity;
}

/*!
 * @brief This function returns the value of member severity
 * @return Value of member severity
 */
double AMM::Physiology::PainStimulus::Data::severity() const
{
    return m_severity;
}

/*!
 * @brief This function returns a reference to member severity
 * @return Reference to member severity
 */
double& AMM::Physiology::PainStimulus::Data::severity()
{
    return m_severity;
}

size_t AMM::Physiology::PainStimulus::Data::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;





    return current_align;
}

bool AMM::Physiology::PainStimulus::Data::isKeyDefined()
{
   return false;
}

void AMM::Physiology::PainStimulus::Data::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}


AMM::Physiology::Sepsis::Data::Data()
{
    m_location = AMM::Physiology::BoneTissue;
    m_severity = 0.0;

}

AMM::Physiology::Sepsis::Data::~Data()
{


}

AMM::Physiology::Sepsis::Data::Data(const Data &x)
{
    m_location = x.m_location;
    m_severity = x.m_severity;
}

AMM::Physiology::Sepsis::Data::Data(Data &&x)
{
    m_location = x.m_location;
    m_severity = x.m_severity;
}

AMM::Physiology::Sepsis::Data& AMM::Physiology::Sepsis::Data::operator=(const Data &x)
{

    m_location = x.m_location;
    m_severity = x.m_severity;

    return *this;
}

AMM::Physiology::Sepsis::Data& AMM::Physiology::Sepsis::Data::operator=(Data &&x)
{

    m_location = x.m_location;
    m_severity = x.m_severity;

    return *this;
}

size_t AMM::Physiology::Sepsis::Data::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t AMM::Physiology::Sepsis::Data::getCdrSerializedSize(const AMM::Physiology::Sepsis::Data& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void AMM::Physiology::Sepsis::Data::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << (uint32_t)m_location;
    scdr << m_severity;
}

void AMM::Physiology::Sepsis::Data::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_location = (AMM::Physiology::TissueCompartment)enum_value;
    }

    dcdr >> m_severity;
}

/*!
 * @brief This function sets a value in member location
 * @param _location New value for member location
 */
void AMM::Physiology::Sepsis::Data::location(AMM::Physiology::TissueCompartment _location)
{
m_location = _location;
}

/*!
 * @brief This function returns the value of member location
 * @return Value of member location
 */
AMM::Physiology::TissueCompartment AMM::Physiology::Sepsis::Data::location() const
{
    return m_location;
}

/*!
 * @brief This function returns a reference to member location
 * @return Reference to member location
 */
AMM::Physiology::TissueCompartment& AMM::Physiology::Sepsis::Data::location()
{
    return m_location;
}
/*!
 * @brief This function sets a value in member severity
 * @param _severity New value for member severity
 */
void AMM::Physiology::Sepsis::Data::severity(double _severity)
{
m_severity = _severity;
}

/*!
 * @brief This function returns the value of member severity
 * @return Value of member severity
 */
double AMM::Physiology::Sepsis::Data::severity() const
{
    return m_severity;
}

/*!
 * @brief This function returns a reference to member severity
 * @return Reference to member severity
 */
double& AMM::Physiology::Sepsis::Data::severity()
{
    return m_severity;
}

size_t AMM::Physiology::Sepsis::Data::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;





    return current_align;
}

bool AMM::Physiology::Sepsis::Data::isKeyDefined()
{
   return false;
}

void AMM::Physiology::Sepsis::Data::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}


AMM::Physiology::Modification::Modification()
{






}

AMM::Physiology::Modification::~Modification()
{





}

AMM::Physiology::Modification::Modification(const Modification &x)
{
    m_id = x.m_id;
    m_location = x.m_location;
    m_practitioner = x.m_practitioner;
    m_type = x.m_type;
    m_payload = x.m_payload;
}

AMM::Physiology::Modification::Modification(Modification &&x)
{
    m_id = std::move(x.m_id);
    m_location = std::move(x.m_location);
    m_practitioner = std::move(x.m_practitioner);
    m_type = std::move(x.m_type);
    m_payload = std::move(x.m_payload);
}

AMM::Physiology::Modification& AMM::Physiology::Modification::operator=(const Modification &x)
{

    m_id = x.m_id;
    m_location = x.m_location;
    m_practitioner = x.m_practitioner;
    m_type = x.m_type;
    m_payload = x.m_payload;

    return *this;
}

AMM::Physiology::Modification& AMM::Physiology::Modification::operator=(Modification &&x)
{

    m_id = std::move(x.m_id);
    m_location = std::move(x.m_location);
    m_practitioner = std::move(x.m_practitioner);
    m_type = std::move(x.m_type);
    m_payload = std::move(x.m_payload);

    return *this;
}

size_t AMM::Physiology::Modification::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += AMM::FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Physiology::Modification::getCdrSerializedSize(const AMM::Physiology::Modification& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += AMM::UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += AMM::FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.practitioner().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.payload().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Physiology::Modification::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_id;
    scdr << m_location;
    scdr << m_practitioner;
    scdr << m_type;
    scdr << m_payload;
}

void AMM::Physiology::Modification::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_id;
    dcdr >> m_location;
    dcdr >> m_practitioner;
    dcdr >> m_type;
    dcdr >> m_payload;
}

/*!
 * @brief This function copies the value in member id
 * @param _id New value to be copied in member id
 */
void AMM::Physiology::Modification::id(const AMM::UUID &_id)
{
m_id = _id;
}

/*!
 * @brief This function moves the value in member id
 * @param _id New value to be moved in member id
 */
void AMM::Physiology::Modification::id(AMM::UUID &&_id)
{
m_id = std::move(_id);
}

/*!
 * @brief This function returns a constant reference to member id
 * @return Constant reference to member id
 */
const AMM::UUID& AMM::Physiology::Modification::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
AMM::UUID& AMM::Physiology::Modification::id()
{
    return m_id;
}
/*!
 * @brief This function copies the value in member location
 * @param _location New value to be copied in member location
 */
void AMM::Physiology::Modification::location(const AMM::FMA_Location &_location)
{
m_location = _location;
}

/*!
 * @brief This function moves the value in member location
 * @param _location New value to be moved in member location
 */
void AMM::Physiology::Modification::location(AMM::FMA_Location &&_location)
{
m_location = std::move(_location);
}

/*!
 * @brief This function returns a constant reference to member location
 * @return Constant reference to member location
 */
const AMM::FMA_Location& AMM::Physiology::Modification::location() const
{
    return m_location;
}

/*!
 * @brief This function returns a reference to member location
 * @return Reference to member location
 */
AMM::FMA_Location& AMM::Physiology::Modification::location()
{
    return m_location;
}
/*!
 * @brief This function copies the value in member practitioner
 * @param _practitioner New value to be copied in member practitioner
 */
void AMM::Physiology::Modification::practitioner(const std::string &_practitioner)
{
m_practitioner = _practitioner;
}

/*!
 * @brief This function moves the value in member practitioner
 * @param _practitioner New value to be moved in member practitioner
 */
void AMM::Physiology::Modification::practitioner(std::string &&_practitioner)
{
m_practitioner = std::move(_practitioner);
}

/*!
 * @brief This function returns a constant reference to member practitioner
 * @return Constant reference to member practitioner
 */
const std::string& AMM::Physiology::Modification::practitioner() const
{
    return m_practitioner;
}

/*!
 * @brief This function returns a reference to member practitioner
 * @return Reference to member practitioner
 */
std::string& AMM::Physiology::Modification::practitioner()
{
    return m_practitioner;
}
/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
void AMM::Physiology::Modification::type(const std::string &_type)
{
m_type = _type;
}

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
void AMM::Physiology::Modification::type(std::string &&_type)
{
m_type = std::move(_type);
}

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
const std::string& AMM::Physiology::Modification::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
std::string& AMM::Physiology::Modification::type()
{
    return m_type;
}
/*!
 * @brief This function copies the value in member payload
 * @param _payload New value to be copied in member payload
 */
void AMM::Physiology::Modification::payload(const std::string &_payload)
{
m_payload = _payload;
}

/*!
 * @brief This function moves the value in member payload
 * @param _payload New value to be moved in member payload
 */
void AMM::Physiology::Modification::payload(std::string &&_payload)
{
m_payload = std::move(_payload);
}

/*!
 * @brief This function returns a constant reference to member payload
 * @return Constant reference to member payload
 */
const std::string& AMM::Physiology::Modification::payload() const
{
    return m_payload;
}

/*!
 * @brief This function returns a reference to member payload
 * @return Reference to member payload
 */
std::string& AMM::Physiology::Modification::payload()
{
    return m_payload;
}

size_t AMM::Physiology::Modification::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;








    return current_align;
}

bool AMM::Physiology::Modification::isKeyDefined()
{
   return false;
}

void AMM::Physiology::Modification::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
}

AMM::Physiology::Node::Node()
{
    m_frame = 0;


    m_dbl = 0.0;


}

AMM::Physiology::Node::~Node()
{





}

AMM::Physiology::Node::Node(const Node &x)
{
    m_frame = x.m_frame;
    m_nodepath = x.m_nodepath;
    m_unit = x.m_unit;
    m_dbl = x.m_dbl;
    m_str = x.m_str;
}

AMM::Physiology::Node::Node(Node &&x)
{
    m_frame = x.m_frame;
    m_nodepath = std::move(x.m_nodepath);
    m_unit = std::move(x.m_unit);
    m_dbl = x.m_dbl;
    m_str = std::move(x.m_str);
}

AMM::Physiology::Node& AMM::Physiology::Node::operator=(const Node &x)
{

    m_frame = x.m_frame;
    m_nodepath = x.m_nodepath;
    m_unit = x.m_unit;
    m_dbl = x.m_dbl;
    m_str = x.m_str;

    return *this;
}

AMM::Physiology::Node& AMM::Physiology::Node::operator=(Node &&x)
{

    m_frame = x.m_frame;
    m_nodepath = std::move(x.m_nodepath);
    m_unit = std::move(x.m_unit);
    m_dbl = x.m_dbl;
    m_str = std::move(x.m_str);

    return *this;
}

size_t AMM::Physiology::Node::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Physiology::Node::getCdrSerializedSize(const AMM::Physiology::Node& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.nodepath().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.unit().size() + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.str().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Physiology::Node::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_frame;
    scdr << m_nodepath;
    scdr << m_unit;
    scdr << m_dbl;
    scdr << m_str;
}

void AMM::Physiology::Node::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_frame;
    dcdr >> m_nodepath;
    dcdr >> m_unit;
    dcdr >> m_dbl;
    dcdr >> m_str;
}

/*!
 * @brief This function sets a value in member frame
 * @param _frame New value for member frame
 */
void AMM::Physiology::Node::frame(int64_t _frame)
{
m_frame = _frame;
}

/*!
 * @brief This function returns the value of member frame
 * @return Value of member frame
 */
int64_t AMM::Physiology::Node::frame() const
{
    return m_frame;
}

/*!
 * @brief This function returns a reference to member frame
 * @return Reference to member frame
 */
int64_t& AMM::Physiology::Node::frame()
{
    return m_frame;
}
/*!
 * @brief This function copies the value in member nodepath
 * @param _nodepath New value to be copied in member nodepath
 */
void AMM::Physiology::Node::nodepath(const std::string &_nodepath)
{
m_nodepath = _nodepath;
}

/*!
 * @brief This function moves the value in member nodepath
 * @param _nodepath New value to be moved in member nodepath
 */
void AMM::Physiology::Node::nodepath(std::string &&_nodepath)
{
m_nodepath = std::move(_nodepath);
}

/*!
 * @brief This function returns a constant reference to member nodepath
 * @return Constant reference to member nodepath
 */
const std::string& AMM::Physiology::Node::nodepath() const
{
    return m_nodepath;
}

/*!
 * @brief This function returns a reference to member nodepath
 * @return Reference to member nodepath
 */
std::string& AMM::Physiology::Node::nodepath()
{
    return m_nodepath;
}
/*!
 * @brief This function copies the value in member unit
 * @param _unit New value to be copied in member unit
 */
void AMM::Physiology::Node::unit(const std::string &_unit)
{
m_unit = _unit;
}

/*!
 * @brief This function moves the value in member unit
 * @param _unit New value to be moved in member unit
 */
void AMM::Physiology::Node::unit(std::string &&_unit)
{
m_unit = std::move(_unit);
}

/*!
 * @brief This function returns a constant reference to member unit
 * @return Constant reference to member unit
 */
const std::string& AMM::Physiology::Node::unit() const
{
    return m_unit;
}

/*!
 * @brief This function returns a reference to member unit
 * @return Reference to member unit
 */
std::string& AMM::Physiology::Node::unit()
{
    return m_unit;
}
/*!
 * @brief This function sets a value in member dbl
 * @param _dbl New value for member dbl
 */
void AMM::Physiology::Node::dbl(double _dbl)
{
m_dbl = _dbl;
}

/*!
 * @brief This function returns the value of member dbl
 * @return Value of member dbl
 */
double AMM::Physiology::Node::dbl() const
{
    return m_dbl;
}

/*!
 * @brief This function returns a reference to member dbl
 * @return Reference to member dbl
 */
double& AMM::Physiology::Node::dbl()
{
    return m_dbl;
}
/*!
 * @brief This function copies the value in member str
 * @param _str New value to be copied in member str
 */
void AMM::Physiology::Node::str(const std::string &_str)
{
m_str = _str;
}

/*!
 * @brief This function moves the value in member str
 * @param _str New value to be moved in member str
 */
void AMM::Physiology::Node::str(std::string &&_str)
{
m_str = std::move(_str);
}

/*!
 * @brief This function returns a constant reference to member str
 * @return Constant reference to member str
 */
const std::string& AMM::Physiology::Node::str() const
{
    return m_str;
}

/*!
 * @brief This function returns a reference to member str
 * @return Reference to member str
 */
std::string& AMM::Physiology::Node::str()
{
    return m_str;
}

size_t AMM::Physiology::Node::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;


     current_align += 8 + eprosima::fastcdr::Cdr::alignment(current_align, 8);

     
     current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4) + 255 + 1;
     




    return current_align;
}

bool AMM::Physiology::Node::isKeyDefined()
{
   return true;
}

void AMM::Physiology::Node::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_frame;  
	 scdr << m_nodepath;  
	 
	 
	 
}

AMM::Physiology::HighFrequencyNode::HighFrequencyNode()
{
    m_frame = 0;


    m_dbl = 0.0;


}

AMM::Physiology::HighFrequencyNode::~HighFrequencyNode()
{





}

AMM::Physiology::HighFrequencyNode::HighFrequencyNode(const HighFrequencyNode &x)
{
    m_frame = x.m_frame;
    m_nodepath = x.m_nodepath;
    m_unit = x.m_unit;
    m_dbl = x.m_dbl;
    m_str = x.m_str;
}

AMM::Physiology::HighFrequencyNode::HighFrequencyNode(HighFrequencyNode &&x)
{
    m_frame = x.m_frame;
    m_nodepath = std::move(x.m_nodepath);
    m_unit = std::move(x.m_unit);
    m_dbl = x.m_dbl;
    m_str = std::move(x.m_str);
}

AMM::Physiology::HighFrequencyNode& AMM::Physiology::HighFrequencyNode::operator=(const HighFrequencyNode &x)
{

    m_frame = x.m_frame;
    m_nodepath = x.m_nodepath;
    m_unit = x.m_unit;
    m_dbl = x.m_dbl;
    m_str = x.m_str;

    return *this;
}

AMM::Physiology::HighFrequencyNode& AMM::Physiology::HighFrequencyNode::operator=(HighFrequencyNode &&x)
{

    m_frame = x.m_frame;
    m_nodepath = std::move(x.m_nodepath);
    m_unit = std::move(x.m_unit);
    m_dbl = x.m_dbl;
    m_str = std::move(x.m_str);

    return *this;
}

size_t AMM::Physiology::HighFrequencyNode::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Physiology::HighFrequencyNode::getCdrSerializedSize(const AMM::Physiology::HighFrequencyNode& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.nodepath().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.unit().size() + 1;

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.str().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Physiology::HighFrequencyNode::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_frame;
    scdr << m_nodepath;
    scdr << m_unit;
    scdr << m_dbl;
    scdr << m_str;
}

void AMM::Physiology::HighFrequencyNode::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_frame;
    dcdr >> m_nodepath;
    dcdr >> m_unit;
    dcdr >> m_dbl;
    dcdr >> m_str;
}

/*!
 * @brief This function sets a value in member frame
 * @param _frame New value for member frame
 */
void AMM::Physiology::HighFrequencyNode::frame(int64_t _frame)
{
m_frame = _frame;
}

/*!
 * @brief This function returns the value of member frame
 * @return Value of member frame
 */
int64_t AMM::Physiology::HighFrequencyNode::frame() const
{
    return m_frame;
}

/*!
 * @brief This function returns a reference to member frame
 * @return Reference to member frame
 */
int64_t& AMM::Physiology::HighFrequencyNode::frame()
{
    return m_frame;
}
/*!
 * @brief This function copies the value in member nodepath
 * @param _nodepath New value to be copied in member nodepath
 */
void AMM::Physiology::HighFrequencyNode::nodepath(const std::string &_nodepath)
{
m_nodepath = _nodepath;
}

/*!
 * @brief This function moves the value in member nodepath
 * @param _nodepath New value to be moved in member nodepath
 */
void AMM::Physiology::HighFrequencyNode::nodepath(std::string &&_nodepath)
{
m_nodepath = std::move(_nodepath);
}

/*!
 * @brief This function returns a constant reference to member nodepath
 * @return Constant reference to member nodepath
 */
const std::string& AMM::Physiology::HighFrequencyNode::nodepath() const
{
    return m_nodepath;
}

/*!
 * @brief This function returns a reference to member nodepath
 * @return Reference to member nodepath
 */
std::string& AMM::Physiology::HighFrequencyNode::nodepath()
{
    return m_nodepath;
}
/*!
 * @brief This function copies the value in member unit
 * @param _unit New value to be copied in member unit
 */
void AMM::Physiology::HighFrequencyNode::unit(const std::string &_unit)
{
m_unit = _unit;
}

/*!
 * @brief This function moves the value in member unit
 * @param _unit New value to be moved in member unit
 */
void AMM::Physiology::HighFrequencyNode::unit(std::string &&_unit)
{
m_unit = std::move(_unit);
}

/*!
 * @brief This function returns a constant reference to member unit
 * @return Constant reference to member unit
 */
const std::string& AMM::Physiology::HighFrequencyNode::unit() const
{
    return m_unit;
}

/*!
 * @brief This function returns a reference to member unit
 * @return Reference to member unit
 */
std::string& AMM::Physiology::HighFrequencyNode::unit()
{
    return m_unit;
}
/*!
 * @brief This function sets a value in member dbl
 * @param _dbl New value for member dbl
 */
void AMM::Physiology::HighFrequencyNode::dbl(double _dbl)
{
m_dbl = _dbl;
}

/*!
 * @brief This function returns the value of member dbl
 * @return Value of member dbl
 */
double AMM::Physiology::HighFrequencyNode::dbl() const
{
    return m_dbl;
}

/*!
 * @brief This function returns a reference to member dbl
 * @return Reference to member dbl
 */
double& AMM::Physiology::HighFrequencyNode::dbl()
{
    return m_dbl;
}
/*!
 * @brief This function copies the value in member str
 * @param _str New value to be copied in member str
 */
void AMM::Physiology::HighFrequencyNode::str(const std::string &_str)
{
m_str = _str;
}

/*!
 * @brief This function moves the value in member str
 * @param _str New value to be moved in member str
 */
void AMM::Physiology::HighFrequencyNode::str(std::string &&_str)
{
m_str = std::move(_str);
}

/*!
 * @brief This function returns a constant reference to member str
 * @return Constant reference to member str
 */
const std::string& AMM::Physiology::HighFrequencyNode::str() const
{
    return m_str;
}

/*!
 * @brief This function returns a reference to member str
 * @return Reference to member str
 */
std::string& AMM::Physiology::HighFrequencyNode::str()
{
    return m_str;
}

size_t AMM::Physiology::HighFrequencyNode::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;


     current_align += 8 + eprosima::fastcdr::Cdr::alignment(current_align, 8);

     
     current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4) + 255 + 1;
     




    return current_align;
}

bool AMM::Physiology::HighFrequencyNode::isKeyDefined()
{
   return true;
}

void AMM::Physiology::HighFrequencyNode::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 scdr << m_frame;  
	 scdr << m_nodepath;  
	 
	 
	 
}


AMM::Render::Modification::Modification()
{






}

AMM::Render::Modification::~Modification()
{





}

AMM::Render::Modification::Modification(const Modification &x)
{
    m_id = x.m_id;
    m_location = x.m_location;
    m_practitioner = x.m_practitioner;
    m_type = x.m_type;
    m_payload = x.m_payload;
}

AMM::Render::Modification::Modification(Modification &&x)
{
    m_id = std::move(x.m_id);
    m_location = std::move(x.m_location);
    m_practitioner = std::move(x.m_practitioner);
    m_type = std::move(x.m_type);
    m_payload = std::move(x.m_payload);
}

AMM::Render::Modification& AMM::Render::Modification::operator=(const Modification &x)
{

    m_id = x.m_id;
    m_location = x.m_location;
    m_practitioner = x.m_practitioner;
    m_type = x.m_type;
    m_payload = x.m_payload;

    return *this;
}

AMM::Render::Modification& AMM::Render::Modification::operator=(Modification &&x)
{

    m_id = std::move(x.m_id);
    m_location = std::move(x.m_location);
    m_practitioner = std::move(x.m_practitioner);
    m_type = std::move(x.m_type);
    m_payload = std::move(x.m_payload);

    return *this;
}

size_t AMM::Render::Modification::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += AMM::UUID::getMaxCdrSerializedSize(current_alignment);
    current_alignment += AMM::FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Render::Modification::getCdrSerializedSize(const AMM::Render::Modification& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += AMM::UUID::getCdrSerializedSize(data.id(), current_alignment);
    current_alignment += AMM::FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.practitioner().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.payload().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Render::Modification::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_id;
    scdr << m_location;
    scdr << m_practitioner;
    scdr << m_type;
    scdr << m_payload;
}

void AMM::Render::Modification::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_id;
    dcdr >> m_location;
    dcdr >> m_practitioner;
    dcdr >> m_type;
    dcdr >> m_payload;
}

/*!
 * @brief This function copies the value in member id
 * @param _id New value to be copied in member id
 */
void AMM::Render::Modification::id(const AMM::UUID &_id)
{
m_id = _id;
}

/*!
 * @brief This function moves the value in member id
 * @param _id New value to be moved in member id
 */
void AMM::Render::Modification::id(AMM::UUID &&_id)
{
m_id = std::move(_id);
}

/*!
 * @brief This function returns a constant reference to member id
 * @return Constant reference to member id
 */
const AMM::UUID& AMM::Render::Modification::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
AMM::UUID& AMM::Render::Modification::id()
{
    return m_id;
}
/*!
 * @brief This function copies the value in member location
 * @param _location New value to be copied in member location
 */
void AMM::Render::Modification::location(const AMM::FMA_Location &_location)
{
m_location = _location;
}

/*!
 * @brief This function moves the value in member location
 * @param _location New value to be moved in member location
 */
void AMM::Render::Modification::location(AMM::FMA_Location &&_location)
{
m_location = std::move(_location);
}

/*!
 * @brief This function returns a constant reference to member location
 * @return Constant reference to member location
 */
const AMM::FMA_Location& AMM::Render::Modification::location() const
{
    return m_location;
}

/*!
 * @brief This function returns a reference to member location
 * @return Reference to member location
 */
AMM::FMA_Location& AMM::Render::Modification::location()
{
    return m_location;
}
/*!
 * @brief This function copies the value in member practitioner
 * @param _practitioner New value to be copied in member practitioner
 */
void AMM::Render::Modification::practitioner(const std::string &_practitioner)
{
m_practitioner = _practitioner;
}

/*!
 * @brief This function moves the value in member practitioner
 * @param _practitioner New value to be moved in member practitioner
 */
void AMM::Render::Modification::practitioner(std::string &&_practitioner)
{
m_practitioner = std::move(_practitioner);
}

/*!
 * @brief This function returns a constant reference to member practitioner
 * @return Constant reference to member practitioner
 */
const std::string& AMM::Render::Modification::practitioner() const
{
    return m_practitioner;
}

/*!
 * @brief This function returns a reference to member practitioner
 * @return Reference to member practitioner
 */
std::string& AMM::Render::Modification::practitioner()
{
    return m_practitioner;
}
/*!
 * @brief This function copies the value in member type
 * @param _type New value to be copied in member type
 */
void AMM::Render::Modification::type(const std::string &_type)
{
m_type = _type;
}

/*!
 * @brief This function moves the value in member type
 * @param _type New value to be moved in member type
 */
void AMM::Render::Modification::type(std::string &&_type)
{
m_type = std::move(_type);
}

/*!
 * @brief This function returns a constant reference to member type
 * @return Constant reference to member type
 */
const std::string& AMM::Render::Modification::type() const
{
    return m_type;
}

/*!
 * @brief This function returns a reference to member type
 * @return Reference to member type
 */
std::string& AMM::Render::Modification::type()
{
    return m_type;
}
/*!
 * @brief This function copies the value in member payload
 * @param _payload New value to be copied in member payload
 */
void AMM::Render::Modification::payload(const std::string &_payload)
{
m_payload = _payload;
}

/*!
 * @brief This function moves the value in member payload
 * @param _payload New value to be moved in member payload
 */
void AMM::Render::Modification::payload(std::string &&_payload)
{
m_payload = std::move(_payload);
}

/*!
 * @brief This function returns a constant reference to member payload
 * @return Constant reference to member payload
 */
const std::string& AMM::Render::Modification::payload() const
{
    return m_payload;
}

/*!
 * @brief This function returns a reference to member payload
 * @return Reference to member payload
 */
std::string& AMM::Render::Modification::payload()
{
    return m_payload;
}

size_t AMM::Render::Modification::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;








    return current_align;
}

bool AMM::Render::Modification::isKeyDefined()
{
   return false;
}

void AMM::Render::Modification::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
}


AMM::PatientAction::BioGears::Command::Command()
{

}

AMM::PatientAction::BioGears::Command::~Command()
{
}

AMM::PatientAction::BioGears::Command::Command(const Command &x)
{
    m_message = x.m_message;
}

AMM::PatientAction::BioGears::Command::Command(Command &&x)
{
    m_message = std::move(x.m_message);
}

AMM::PatientAction::BioGears::Command& AMM::PatientAction::BioGears::Command::operator=(const Command &x)
{

    m_message = x.m_message;

    return *this;
}

AMM::PatientAction::BioGears::Command& AMM::PatientAction::BioGears::Command::operator=(Command &&x)
{

    m_message = std::move(x.m_message);

    return *this;
}

size_t AMM::PatientAction::BioGears::Command::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t AMM::PatientAction::BioGears::Command::getCdrSerializedSize(const AMM::PatientAction::BioGears::Command& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.message().size() + 1;

    return current_alignment - initial_alignment;
}

void AMM::PatientAction::BioGears::Command::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_message;
}

void AMM::PatientAction::BioGears::Command::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_message;
}

/*!
 * @brief This function copies the value in member message
 * @param _message New value to be copied in member message
 */
void AMM::PatientAction::BioGears::Command::message(const std::string &_message)
{
m_message = _message;
}

/*!
 * @brief This function moves the value in member message
 * @param _message New value to be moved in member message
 */
void AMM::PatientAction::BioGears::Command::message(std::string &&_message)
{
m_message = std::move(_message);
}

/*!
 * @brief This function returns a constant reference to member message
 * @return Constant reference to member message
 */
const std::string& AMM::PatientAction::BioGears::Command::message() const
{
    return m_message;
}

/*!
 * @brief This function returns a reference to member message
 * @return Reference to member message
 */
std::string& AMM::PatientAction::BioGears::Command::message()
{
    return m_message;
}

size_t AMM::PatientAction::BioGears::Command::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;



    return current_align;
}

bool AMM::PatientAction::BioGears::Command::isKeyDefined()
{
   return false;
}

void AMM::PatientAction::BioGears::Command::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
}



AMM::Performance::xAPIModifier::xAPIModifier()
{



}

AMM::Performance::xAPIModifier::~xAPIModifier()
{


}

AMM::Performance::xAPIModifier::xAPIModifier(const xAPIModifier &x)
{
    m_key = x.m_key;
    m_value = x.m_value;
}

AMM::Performance::xAPIModifier::xAPIModifier(xAPIModifier &&x)
{
    m_key = std::move(x.m_key);
    m_value = std::move(x.m_value);
}

AMM::Performance::xAPIModifier& AMM::Performance::xAPIModifier::operator=(const xAPIModifier &x)
{

    m_key = x.m_key;
    m_value = x.m_value;

    return *this;
}

AMM::Performance::xAPIModifier& AMM::Performance::xAPIModifier::operator=(xAPIModifier &&x)
{

    m_key = std::move(x.m_key);
    m_value = std::move(x.m_value);

    return *this;
}

size_t AMM::Performance::xAPIModifier::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Performance::xAPIModifier::getCdrSerializedSize(const AMM::Performance::xAPIModifier& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.key().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.value().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Performance::xAPIModifier::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_key;
    scdr << m_value;
}

void AMM::Performance::xAPIModifier::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_key;
    dcdr >> m_value;
}

/*!
 * @brief This function copies the value in member key
 * @param _key New value to be copied in member key
 */
void AMM::Performance::xAPIModifier::key(const std::string &_key)
{
m_key = _key;
}

/*!
 * @brief This function moves the value in member key
 * @param _key New value to be moved in member key
 */
void AMM::Performance::xAPIModifier::key(std::string &&_key)
{
m_key = std::move(_key);
}

/*!
 * @brief This function returns a constant reference to member key
 * @return Constant reference to member key
 */
const std::string& AMM::Performance::xAPIModifier::key() const
{
    return m_key;
}

/*!
 * @brief This function returns a reference to member key
 * @return Reference to member key
 */
std::string& AMM::Performance::xAPIModifier::key()
{
    return m_key;
}
/*!
 * @brief This function copies the value in member value
 * @param _value New value to be copied in member value
 */
void AMM::Performance::xAPIModifier::value(const std::string &_value)
{
m_value = _value;
}

/*!
 * @brief This function moves the value in member value
 * @param _value New value to be moved in member value
 */
void AMM::Performance::xAPIModifier::value(std::string &&_value)
{
m_value = std::move(_value);
}

/*!
 * @brief This function returns a constant reference to member value
 * @return Constant reference to member value
 */
const std::string& AMM::Performance::xAPIModifier::value() const
{
    return m_value;
}

/*!
 * @brief This function returns a reference to member value
 * @return Reference to member value
 */
std::string& AMM::Performance::xAPIModifier::value()
{
    return m_value;
}

size_t AMM::Performance::xAPIModifier::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;





    return current_align;
}

bool AMM::Performance::xAPIModifier::isKeyDefined()
{
   return false;
}

void AMM::Performance::xAPIModifier::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}


AMM::Performance::Statement::Statement()
{







}

AMM::Performance::Statement::~Statement()
{






}

AMM::Performance::Statement::Statement(const Statement &x)
{
    m_noun = x.m_noun;
    m_noun_modifiers = x.m_noun_modifiers;
    m_verb = x.m_verb;
    m_verb_modifiers = x.m_verb_modifiers;
    m_obj = x.m_obj;
    m_obj_modifiers = x.m_obj_modifiers;
}

AMM::Performance::Statement::Statement(Statement &&x)
{
    m_noun = std::move(x.m_noun);
    m_noun_modifiers = std::move(x.m_noun_modifiers);
    m_verb = std::move(x.m_verb);
    m_verb_modifiers = std::move(x.m_verb_modifiers);
    m_obj = std::move(x.m_obj);
    m_obj_modifiers = std::move(x.m_obj_modifiers);
}

AMM::Performance::Statement& AMM::Performance::Statement::operator=(const Statement &x)
{

    m_noun = x.m_noun;
    m_noun_modifiers = x.m_noun_modifiers;
    m_verb = x.m_verb;
    m_verb_modifiers = x.m_verb_modifiers;
    m_obj = x.m_obj;
    m_obj_modifiers = x.m_obj_modifiers;

    return *this;
}

AMM::Performance::Statement& AMM::Performance::Statement::operator=(Statement &&x)
{

    m_noun = std::move(x.m_noun);
    m_noun_modifiers = std::move(x.m_noun_modifiers);
    m_verb = std::move(x.m_verb);
    m_verb_modifiers = std::move(x.m_verb_modifiers);
    m_obj = std::move(x.m_obj);
    m_obj_modifiers = std::move(x.m_obj_modifiers);

    return *this;
}

size_t AMM::Performance::Statement::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += AMM::Performance::xAPIModifier::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += AMM::Performance::xAPIModifier::getMaxCdrSerializedSize(current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += AMM::Performance::xAPIModifier::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t AMM::Performance::Statement::getCdrSerializedSize(const AMM::Performance::Statement& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.noun().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.noun_modifiers().size(); ++a)
    {
        current_alignment += AMM::Performance::xAPIModifier::getCdrSerializedSize(data.noun_modifiers().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.verb().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.verb_modifiers().size(); ++a)
    {
        current_alignment += AMM::Performance::xAPIModifier::getCdrSerializedSize(data.verb_modifiers().at(a), current_alignment);}

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.obj().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.obj_modifiers().size(); ++a)
    {
        current_alignment += AMM::Performance::xAPIModifier::getCdrSerializedSize(data.obj_modifiers().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void AMM::Performance::Statement::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_noun;
    scdr << m_noun_modifiers;
    scdr << m_verb;
    scdr << m_verb_modifiers;
    scdr << m_obj;
    scdr << m_obj_modifiers;
}

void AMM::Performance::Statement::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_noun;
    dcdr >> m_noun_modifiers;
    dcdr >> m_verb;
    dcdr >> m_verb_modifiers;
    dcdr >> m_obj;
    dcdr >> m_obj_modifiers;
}

/*!
 * @brief This function copies the value in member noun
 * @param _noun New value to be copied in member noun
 */
void AMM::Performance::Statement::noun(const std::string &_noun)
{
m_noun = _noun;
}

/*!
 * @brief This function moves the value in member noun
 * @param _noun New value to be moved in member noun
 */
void AMM::Performance::Statement::noun(std::string &&_noun)
{
m_noun = std::move(_noun);
}

/*!
 * @brief This function returns a constant reference to member noun
 * @return Constant reference to member noun
 */
const std::string& AMM::Performance::Statement::noun() const
{
    return m_noun;
}

/*!
 * @brief This function returns a reference to member noun
 * @return Reference to member noun
 */
std::string& AMM::Performance::Statement::noun()
{
    return m_noun;
}
/*!
 * @brief This function copies the value in member noun_modifiers
 * @param _noun_modifiers New value to be copied in member noun_modifiers
 */
void AMM::Performance::Statement::noun_modifiers(const AMM::Performance::xAPI_Modifiers &_noun_modifiers)
{
m_noun_modifiers = _noun_modifiers;
}

/*!
 * @brief This function moves the value in member noun_modifiers
 * @param _noun_modifiers New value to be moved in member noun_modifiers
 */
void AMM::Performance::Statement::noun_modifiers(AMM::Performance::xAPI_Modifiers &&_noun_modifiers)
{
m_noun_modifiers = std::move(_noun_modifiers);
}

/*!
 * @brief This function returns a constant reference to member noun_modifiers
 * @return Constant reference to member noun_modifiers
 */
const AMM::Performance::xAPI_Modifiers& AMM::Performance::Statement::noun_modifiers() const
{
    return m_noun_modifiers;
}

/*!
 * @brief This function returns a reference to member noun_modifiers
 * @return Reference to member noun_modifiers
 */
AMM::Performance::xAPI_Modifiers& AMM::Performance::Statement::noun_modifiers()
{
    return m_noun_modifiers;
}
/*!
 * @brief This function copies the value in member verb
 * @param _verb New value to be copied in member verb
 */
void AMM::Performance::Statement::verb(const std::string &_verb)
{
m_verb = _verb;
}

/*!
 * @brief This function moves the value in member verb
 * @param _verb New value to be moved in member verb
 */
void AMM::Performance::Statement::verb(std::string &&_verb)
{
m_verb = std::move(_verb);
}

/*!
 * @brief This function returns a constant reference to member verb
 * @return Constant reference to member verb
 */
const std::string& AMM::Performance::Statement::verb() const
{
    return m_verb;
}

/*!
 * @brief This function returns a reference to member verb
 * @return Reference to member verb
 */
std::string& AMM::Performance::Statement::verb()
{
    return m_verb;
}
/*!
 * @brief This function copies the value in member verb_modifiers
 * @param _verb_modifiers New value to be copied in member verb_modifiers
 */
void AMM::Performance::Statement::verb_modifiers(const AMM::Performance::xAPI_Modifiers &_verb_modifiers)
{
m_verb_modifiers = _verb_modifiers;
}

/*!
 * @brief This function moves the value in member verb_modifiers
 * @param _verb_modifiers New value to be moved in member verb_modifiers
 */
void AMM::Performance::Statement::verb_modifiers(AMM::Performance::xAPI_Modifiers &&_verb_modifiers)
{
m_verb_modifiers = std::move(_verb_modifiers);
}

/*!
 * @brief This function returns a constant reference to member verb_modifiers
 * @return Constant reference to member verb_modifiers
 */
const AMM::Performance::xAPI_Modifiers& AMM::Performance::Statement::verb_modifiers() const
{
    return m_verb_modifiers;
}

/*!
 * @brief This function returns a reference to member verb_modifiers
 * @return Reference to member verb_modifiers
 */
AMM::Performance::xAPI_Modifiers& AMM::Performance::Statement::verb_modifiers()
{
    return m_verb_modifiers;
}
/*!
 * @brief This function copies the value in member obj
 * @param _obj New value to be copied in member obj
 */
void AMM::Performance::Statement::obj(const std::string &_obj)
{
m_obj = _obj;
}

/*!
 * @brief This function moves the value in member obj
 * @param _obj New value to be moved in member obj
 */
void AMM::Performance::Statement::obj(std::string &&_obj)
{
m_obj = std::move(_obj);
}

/*!
 * @brief This function returns a constant reference to member obj
 * @return Constant reference to member obj
 */
const std::string& AMM::Performance::Statement::obj() const
{
    return m_obj;
}

/*!
 * @brief This function returns a reference to member obj
 * @return Reference to member obj
 */
std::string& AMM::Performance::Statement::obj()
{
    return m_obj;
}
/*!
 * @brief This function copies the value in member obj_modifiers
 * @param _obj_modifiers New value to be copied in member obj_modifiers
 */
void AMM::Performance::Statement::obj_modifiers(const AMM::Performance::xAPI_Modifiers &_obj_modifiers)
{
m_obj_modifiers = _obj_modifiers;
}

/*!
 * @brief This function moves the value in member obj_modifiers
 * @param _obj_modifiers New value to be moved in member obj_modifiers
 */
void AMM::Performance::Statement::obj_modifiers(AMM::Performance::xAPI_Modifiers &&_obj_modifiers)
{
m_obj_modifiers = std::move(_obj_modifiers);
}

/*!
 * @brief This function returns a constant reference to member obj_modifiers
 * @return Constant reference to member obj_modifiers
 */
const AMM::Performance::xAPI_Modifiers& AMM::Performance::Statement::obj_modifiers() const
{
    return m_obj_modifiers;
}

/*!
 * @brief This function returns a reference to member obj_modifiers
 * @return Reference to member obj_modifiers
 */
AMM::Performance::xAPI_Modifiers& AMM::Performance::Statement::obj_modifiers()
{
    return m_obj_modifiers;
}

size_t AMM::Performance::Statement::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;









    return current_align;
}

bool AMM::Performance::Statement::isKeyDefined()
{
   return false;
}

void AMM::Performance::Statement::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
}

AMM::Performance::Assessment::Assessment()
{








}

AMM::Performance::Assessment::~Assessment()
{







}

AMM::Performance::Assessment::Assessment(const Assessment &x)
{
    m_Timestamp = x.m_Timestamp;
    m_learner_id = x.m_learner_id;
    m_location = x.m_location;
    m_assessment_type = x.m_assessment_type;
    m_assessment_info = x.m_assessment_info;
    m_step = x.m_step;
    m_comment = x.m_comment;
}

AMM::Performance::Assessment::Assessment(Assessment &&x)
{
    m_Timestamp = std::move(x.m_Timestamp);
    m_learner_id = std::move(x.m_learner_id);
    m_location = std::move(x.m_location);
    m_assessment_type = std::move(x.m_assessment_type);
    m_assessment_info = std::move(x.m_assessment_info);
    m_step = std::move(x.m_step);
    m_comment = std::move(x.m_comment);
}

AMM::Performance::Assessment& AMM::Performance::Assessment::operator=(const Assessment &x)
{

    m_Timestamp = x.m_Timestamp;
    m_learner_id = x.m_learner_id;
    m_location = x.m_location;
    m_assessment_type = x.m_assessment_type;
    m_assessment_info = x.m_assessment_info;
    m_step = x.m_step;
    m_comment = x.m_comment;

    return *this;
}

AMM::Performance::Assessment& AMM::Performance::Assessment::operator=(Assessment &&x)
{

    m_Timestamp = std::move(x.m_Timestamp);
    m_learner_id = std::move(x.m_learner_id);
    m_location = std::move(x.m_location);
    m_assessment_type = std::move(x.m_assessment_type);
    m_assessment_info = std::move(x.m_assessment_info);
    m_step = std::move(x.m_step);
    m_comment = std::move(x.m_comment);

    return *this;
}

size_t AMM::Performance::Assessment::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += AMM::FMA_Location::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Performance::Assessment::getCdrSerializedSize(const AMM::Performance::Assessment& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.Timestamp().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.learner_id().size() + 1;

    current_alignment += AMM::FMA_Location::getCdrSerializedSize(data.location(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.assessment_type().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.assessment_info().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.step().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.comment().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Performance::Assessment::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_Timestamp;
    scdr << m_learner_id;
    scdr << m_location;
    scdr << m_assessment_type;
    scdr << m_assessment_info;
    scdr << m_step;
    scdr << m_comment;
}

void AMM::Performance::Assessment::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_Timestamp;
    dcdr >> m_learner_id;
    dcdr >> m_location;
    dcdr >> m_assessment_type;
    dcdr >> m_assessment_info;
    dcdr >> m_step;
    dcdr >> m_comment;
}

/*!
 * @brief This function copies the value in member Timestamp
 * @param _Timestamp New value to be copied in member Timestamp
 */
void AMM::Performance::Assessment::Timestamp(const std::string &_Timestamp)
{
m_Timestamp = _Timestamp;
}

/*!
 * @brief This function moves the value in member Timestamp
 * @param _Timestamp New value to be moved in member Timestamp
 */
void AMM::Performance::Assessment::Timestamp(std::string &&_Timestamp)
{
m_Timestamp = std::move(_Timestamp);
}

/*!
 * @brief This function returns a constant reference to member Timestamp
 * @return Constant reference to member Timestamp
 */
const std::string& AMM::Performance::Assessment::Timestamp() const
{
    return m_Timestamp;
}

/*!
 * @brief This function returns a reference to member Timestamp
 * @return Reference to member Timestamp
 */
std::string& AMM::Performance::Assessment::Timestamp()
{
    return m_Timestamp;
}
/*!
 * @brief This function copies the value in member learner_id
 * @param _learner_id New value to be copied in member learner_id
 */
void AMM::Performance::Assessment::learner_id(const std::string &_learner_id)
{
m_learner_id = _learner_id;
}

/*!
 * @brief This function moves the value in member learner_id
 * @param _learner_id New value to be moved in member learner_id
 */
void AMM::Performance::Assessment::learner_id(std::string &&_learner_id)
{
m_learner_id = std::move(_learner_id);
}

/*!
 * @brief This function returns a constant reference to member learner_id
 * @return Constant reference to member learner_id
 */
const std::string& AMM::Performance::Assessment::learner_id() const
{
    return m_learner_id;
}

/*!
 * @brief This function returns a reference to member learner_id
 * @return Reference to member learner_id
 */
std::string& AMM::Performance::Assessment::learner_id()
{
    return m_learner_id;
}
/*!
 * @brief This function copies the value in member location
 * @param _location New value to be copied in member location
 */
void AMM::Performance::Assessment::location(const AMM::FMA_Location &_location)
{
m_location = _location;
}

/*!
 * @brief This function moves the value in member location
 * @param _location New value to be moved in member location
 */
void AMM::Performance::Assessment::location(AMM::FMA_Location &&_location)
{
m_location = std::move(_location);
}

/*!
 * @brief This function returns a constant reference to member location
 * @return Constant reference to member location
 */
const AMM::FMA_Location& AMM::Performance::Assessment::location() const
{
    return m_location;
}

/*!
 * @brief This function returns a reference to member location
 * @return Reference to member location
 */
AMM::FMA_Location& AMM::Performance::Assessment::location()
{
    return m_location;
}
/*!
 * @brief This function copies the value in member assessment_type
 * @param _assessment_type New value to be copied in member assessment_type
 */
void AMM::Performance::Assessment::assessment_type(const std::string &_assessment_type)
{
m_assessment_type = _assessment_type;
}

/*!
 * @brief This function moves the value in member assessment_type
 * @param _assessment_type New value to be moved in member assessment_type
 */
void AMM::Performance::Assessment::assessment_type(std::string &&_assessment_type)
{
m_assessment_type = std::move(_assessment_type);
}

/*!
 * @brief This function returns a constant reference to member assessment_type
 * @return Constant reference to member assessment_type
 */
const std::string& AMM::Performance::Assessment::assessment_type() const
{
    return m_assessment_type;
}

/*!
 * @brief This function returns a reference to member assessment_type
 * @return Reference to member assessment_type
 */
std::string& AMM::Performance::Assessment::assessment_type()
{
    return m_assessment_type;
}
/*!
 * @brief This function copies the value in member assessment_info
 * @param _assessment_info New value to be copied in member assessment_info
 */
void AMM::Performance::Assessment::assessment_info(const std::string &_assessment_info)
{
m_assessment_info = _assessment_info;
}

/*!
 * @brief This function moves the value in member assessment_info
 * @param _assessment_info New value to be moved in member assessment_info
 */
void AMM::Performance::Assessment::assessment_info(std::string &&_assessment_info)
{
m_assessment_info = std::move(_assessment_info);
}

/*!
 * @brief This function returns a constant reference to member assessment_info
 * @return Constant reference to member assessment_info
 */
const std::string& AMM::Performance::Assessment::assessment_info() const
{
    return m_assessment_info;
}

/*!
 * @brief This function returns a reference to member assessment_info
 * @return Reference to member assessment_info
 */
std::string& AMM::Performance::Assessment::assessment_info()
{
    return m_assessment_info;
}
/*!
 * @brief This function copies the value in member step
 * @param _step New value to be copied in member step
 */
void AMM::Performance::Assessment::step(const std::string &_step)
{
m_step = _step;
}

/*!
 * @brief This function moves the value in member step
 * @param _step New value to be moved in member step
 */
void AMM::Performance::Assessment::step(std::string &&_step)
{
m_step = std::move(_step);
}

/*!
 * @brief This function returns a constant reference to member step
 * @return Constant reference to member step
 */
const std::string& AMM::Performance::Assessment::step() const
{
    return m_step;
}

/*!
 * @brief This function returns a reference to member step
 * @return Reference to member step
 */
std::string& AMM::Performance::Assessment::step()
{
    return m_step;
}
/*!
 * @brief This function copies the value in member comment
 * @param _comment New value to be copied in member comment
 */
void AMM::Performance::Assessment::comment(const std::string &_comment)
{
m_comment = _comment;
}

/*!
 * @brief This function moves the value in member comment
 * @param _comment New value to be moved in member comment
 */
void AMM::Performance::Assessment::comment(std::string &&_comment)
{
m_comment = std::move(_comment);
}

/*!
 * @brief This function returns a constant reference to member comment
 * @return Constant reference to member comment
 */
const std::string& AMM::Performance::Assessment::comment() const
{
    return m_comment;
}

/*!
 * @brief This function returns a reference to member comment
 * @return Reference to member comment
 */
std::string& AMM::Performance::Assessment::comment()
{
    return m_comment;
}

size_t AMM::Performance::Assessment::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;










    return current_align;
}

bool AMM::Performance::Assessment::isKeyDefined()
{
   return false;
}

void AMM::Performance::Assessment::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
}


AMM::Resource::Requirement::Power::Power()
{
    m_volts = 0.0;
    m_amps = 0.0;

}

AMM::Resource::Requirement::Power::~Power()
{


}

AMM::Resource::Requirement::Power::Power(const Power &x)
{
    m_volts = x.m_volts;
    m_amps = x.m_amps;
}

AMM::Resource::Requirement::Power::Power(Power &&x)
{
    m_volts = x.m_volts;
    m_amps = x.m_amps;
}

AMM::Resource::Requirement::Power& AMM::Resource::Requirement::Power::operator=(const Power &x)
{

    m_volts = x.m_volts;
    m_amps = x.m_amps;

    return *this;
}

AMM::Resource::Requirement::Power& AMM::Resource::Requirement::Power::operator=(Power &&x)
{

    m_volts = x.m_volts;
    m_amps = x.m_amps;

    return *this;
}

size_t AMM::Resource::Requirement::Power::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Requirement::Power::getCdrSerializedSize(const AMM::Resource::Requirement::Power& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void AMM::Resource::Requirement::Power::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_volts;
    scdr << m_amps;
}

void AMM::Resource::Requirement::Power::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_volts;
    dcdr >> m_amps;
}

/*!
 * @brief This function sets a value in member volts
 * @param _volts New value for member volts
 */
void AMM::Resource::Requirement::Power::volts(double _volts)
{
m_volts = _volts;
}

/*!
 * @brief This function returns the value of member volts
 * @return Value of member volts
 */
double AMM::Resource::Requirement::Power::volts() const
{
    return m_volts;
}

/*!
 * @brief This function returns a reference to member volts
 * @return Reference to member volts
 */
double& AMM::Resource::Requirement::Power::volts()
{
    return m_volts;
}
/*!
 * @brief This function sets a value in member amps
 * @param _amps New value for member amps
 */
void AMM::Resource::Requirement::Power::amps(double _amps)
{
m_amps = _amps;
}

/*!
 * @brief This function returns the value of member amps
 * @return Value of member amps
 */
double AMM::Resource::Requirement::Power::amps() const
{
    return m_amps;
}

/*!
 * @brief This function returns a reference to member amps
 * @return Reference to member amps
 */
double& AMM::Resource::Requirement::Power::amps()
{
    return m_amps;
}

size_t AMM::Resource::Requirement::Power::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;





    return current_align;
}

bool AMM::Resource::Requirement::Power::isKeyDefined()
{
   return false;
}

void AMM::Resource::Requirement::Power::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}

AMM::Resource::Requirement::Blood::Blood()
{
    m_volume = 0.0;

}

AMM::Resource::Requirement::Blood::~Blood()
{
}

AMM::Resource::Requirement::Blood::Blood(const Blood &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Blood::Blood(Blood &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Blood& AMM::Resource::Requirement::Blood::operator=(const Blood &x)
{

    m_volume = x.m_volume;

    return *this;
}

AMM::Resource::Requirement::Blood& AMM::Resource::Requirement::Blood::operator=(Blood &&x)
{

    m_volume = x.m_volume;

    return *this;
}

size_t AMM::Resource::Requirement::Blood::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Requirement::Blood::getCdrSerializedSize(const AMM::Resource::Requirement::Blood& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Requirement::Blood::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_volume;
}

void AMM::Resource::Requirement::Blood::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_volume;
}

/*!
 * @brief This function sets a value in member volume
 * @param _volume New value for member volume
 */
void AMM::Resource::Requirement::Blood::volume(double _volume)
{
m_volume = _volume;
}

/*!
 * @brief This function returns the value of member volume
 * @return Value of member volume
 */
double AMM::Resource::Requirement::Blood::volume() const
{
    return m_volume;
}

/*!
 * @brief This function returns a reference to member volume
 * @return Reference to member volume
 */
double& AMM::Resource::Requirement::Blood::volume()
{
    return m_volume;
}

size_t AMM::Resource::Requirement::Blood::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;



    return current_align;
}

bool AMM::Resource::Requirement::Blood::isKeyDefined()
{
   return false;
}

void AMM::Resource::Requirement::Blood::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
}

AMM::Resource::Requirement::Clear_Liquid::Clear_Liquid()
{
    m_volume = 0.0;

}

AMM::Resource::Requirement::Clear_Liquid::~Clear_Liquid()
{
}

AMM::Resource::Requirement::Clear_Liquid::Clear_Liquid(const Clear_Liquid &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Clear_Liquid::Clear_Liquid(Clear_Liquid &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Clear_Liquid& AMM::Resource::Requirement::Clear_Liquid::operator=(const Clear_Liquid &x)
{

    m_volume = x.m_volume;

    return *this;
}

AMM::Resource::Requirement::Clear_Liquid& AMM::Resource::Requirement::Clear_Liquid::operator=(Clear_Liquid &&x)
{

    m_volume = x.m_volume;

    return *this;
}

size_t AMM::Resource::Requirement::Clear_Liquid::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Requirement::Clear_Liquid::getCdrSerializedSize(const AMM::Resource::Requirement::Clear_Liquid& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Requirement::Clear_Liquid::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_volume;
}

void AMM::Resource::Requirement::Clear_Liquid::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_volume;
}

/*!
 * @brief This function sets a value in member volume
 * @param _volume New value for member volume
 */
void AMM::Resource::Requirement::Clear_Liquid::volume(double _volume)
{
m_volume = _volume;
}

/*!
 * @brief This function returns the value of member volume
 * @return Value of member volume
 */
double AMM::Resource::Requirement::Clear_Liquid::volume() const
{
    return m_volume;
}

/*!
 * @brief This function returns a reference to member volume
 * @return Reference to member volume
 */
double& AMM::Resource::Requirement::Clear_Liquid::volume()
{
    return m_volume;
}

size_t AMM::Resource::Requirement::Clear_Liquid::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;



    return current_align;
}

bool AMM::Resource::Requirement::Clear_Liquid::isKeyDefined()
{
   return false;
}

void AMM::Resource::Requirement::Clear_Liquid::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
}

AMM::Resource::Requirement::Air::Air()
{
    m_volume = 0.0;

}

AMM::Resource::Requirement::Air::~Air()
{
}

AMM::Resource::Requirement::Air::Air(const Air &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Air::Air(Air &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Air& AMM::Resource::Requirement::Air::operator=(const Air &x)
{

    m_volume = x.m_volume;

    return *this;
}

AMM::Resource::Requirement::Air& AMM::Resource::Requirement::Air::operator=(Air &&x)
{

    m_volume = x.m_volume;

    return *this;
}

size_t AMM::Resource::Requirement::Air::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Requirement::Air::getCdrSerializedSize(const AMM::Resource::Requirement::Air& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Requirement::Air::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_volume;
}

void AMM::Resource::Requirement::Air::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_volume;
}

/*!
 * @brief This function sets a value in member volume
 * @param _volume New value for member volume
 */
void AMM::Resource::Requirement::Air::volume(double _volume)
{
m_volume = _volume;
}

/*!
 * @brief This function returns the value of member volume
 * @return Value of member volume
 */
double AMM::Resource::Requirement::Air::volume() const
{
    return m_volume;
}

/*!
 * @brief This function returns a reference to member volume
 * @return Reference to member volume
 */
double& AMM::Resource::Requirement::Air::volume()
{
    return m_volume;
}

size_t AMM::Resource::Requirement::Air::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;



    return current_align;
}

bool AMM::Resource::Requirement::Air::isKeyDefined()
{
   return false;
}

void AMM::Resource::Requirement::Air::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
}

AMM::Resource::Requirement::Cleaning_Solution::Cleaning_Solution()
{
    m_volume = 0.0;

}

AMM::Resource::Requirement::Cleaning_Solution::~Cleaning_Solution()
{
}

AMM::Resource::Requirement::Cleaning_Solution::Cleaning_Solution(const Cleaning_Solution &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Cleaning_Solution::Cleaning_Solution(Cleaning_Solution &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Requirement::Cleaning_Solution& AMM::Resource::Requirement::Cleaning_Solution::operator=(const Cleaning_Solution &x)
{

    m_volume = x.m_volume;

    return *this;
}

AMM::Resource::Requirement::Cleaning_Solution& AMM::Resource::Requirement::Cleaning_Solution::operator=(Cleaning_Solution &&x)
{

    m_volume = x.m_volume;

    return *this;
}

size_t AMM::Resource::Requirement::Cleaning_Solution::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Requirement::Cleaning_Solution::getCdrSerializedSize(const AMM::Resource::Requirement::Cleaning_Solution& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Requirement::Cleaning_Solution::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_volume;
}

void AMM::Resource::Requirement::Cleaning_Solution::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_volume;
}

/*!
 * @brief This function sets a value in member volume
 * @param _volume New value for member volume
 */
void AMM::Resource::Requirement::Cleaning_Solution::volume(double _volume)
{
m_volume = _volume;
}

/*!
 * @brief This function returns the value of member volume
 * @return Value of member volume
 */
double AMM::Resource::Requirement::Cleaning_Solution::volume() const
{
    return m_volume;
}

/*!
 * @brief This function returns a reference to member volume
 * @return Reference to member volume
 */
double& AMM::Resource::Requirement::Cleaning_Solution::volume()
{
    return m_volume;
}

size_t AMM::Resource::Requirement::Cleaning_Solution::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;



    return current_align;
}

bool AMM::Resource::Requirement::Cleaning_Solution::isKeyDefined()
{
   return false;
}

void AMM::Resource::Requirement::Cleaning_Solution::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
}


AMM::Resource::Supply::Power::Power()
{
    m_volts = 0.0;
    m_amps = 0.0;

}

AMM::Resource::Supply::Power::~Power()
{


}

AMM::Resource::Supply::Power::Power(const Power &x)
{
    m_volts = x.m_volts;
    m_amps = x.m_amps;
}

AMM::Resource::Supply::Power::Power(Power &&x)
{
    m_volts = x.m_volts;
    m_amps = x.m_amps;
}

AMM::Resource::Supply::Power& AMM::Resource::Supply::Power::operator=(const Power &x)
{

    m_volts = x.m_volts;
    m_amps = x.m_amps;

    return *this;
}

AMM::Resource::Supply::Power& AMM::Resource::Supply::Power::operator=(Power &&x)
{

    m_volts = x.m_volts;
    m_amps = x.m_amps;

    return *this;
}

size_t AMM::Resource::Supply::Power::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Supply::Power::getCdrSerializedSize(const AMM::Resource::Supply::Power& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);



    return current_alignment - initial_alignment;
}

void AMM::Resource::Supply::Power::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_volts;
    scdr << m_amps;
}

void AMM::Resource::Supply::Power::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_volts;
    dcdr >> m_amps;
}

/*!
 * @brief This function sets a value in member volts
 * @param _volts New value for member volts
 */
void AMM::Resource::Supply::Power::volts(double _volts)
{
m_volts = _volts;
}

/*!
 * @brief This function returns the value of member volts
 * @return Value of member volts
 */
double AMM::Resource::Supply::Power::volts() const
{
    return m_volts;
}

/*!
 * @brief This function returns a reference to member volts
 * @return Reference to member volts
 */
double& AMM::Resource::Supply::Power::volts()
{
    return m_volts;
}
/*!
 * @brief This function sets a value in member amps
 * @param _amps New value for member amps
 */
void AMM::Resource::Supply::Power::amps(double _amps)
{
m_amps = _amps;
}

/*!
 * @brief This function returns the value of member amps
 * @return Value of member amps
 */
double AMM::Resource::Supply::Power::amps() const
{
    return m_amps;
}

/*!
 * @brief This function returns a reference to member amps
 * @return Reference to member amps
 */
double& AMM::Resource::Supply::Power::amps()
{
    return m_amps;
}

size_t AMM::Resource::Supply::Power::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;





    return current_align;
}

bool AMM::Resource::Supply::Power::isKeyDefined()
{
   return false;
}

void AMM::Resource::Supply::Power::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
}

AMM::Resource::Supply::Blood::Blood()
{
    m_volume = 0.0;

}

AMM::Resource::Supply::Blood::~Blood()
{
}

AMM::Resource::Supply::Blood::Blood(const Blood &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Blood::Blood(Blood &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Blood& AMM::Resource::Supply::Blood::operator=(const Blood &x)
{

    m_volume = x.m_volume;

    return *this;
}

AMM::Resource::Supply::Blood& AMM::Resource::Supply::Blood::operator=(Blood &&x)
{

    m_volume = x.m_volume;

    return *this;
}

size_t AMM::Resource::Supply::Blood::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Supply::Blood::getCdrSerializedSize(const AMM::Resource::Supply::Blood& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Supply::Blood::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_volume;
}

void AMM::Resource::Supply::Blood::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_volume;
}

/*!
 * @brief This function sets a value in member volume
 * @param _volume New value for member volume
 */
void AMM::Resource::Supply::Blood::volume(double _volume)
{
m_volume = _volume;
}

/*!
 * @brief This function returns the value of member volume
 * @return Value of member volume
 */
double AMM::Resource::Supply::Blood::volume() const
{
    return m_volume;
}

/*!
 * @brief This function returns a reference to member volume
 * @return Reference to member volume
 */
double& AMM::Resource::Supply::Blood::volume()
{
    return m_volume;
}

size_t AMM::Resource::Supply::Blood::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;



    return current_align;
}

bool AMM::Resource::Supply::Blood::isKeyDefined()
{
   return false;
}

void AMM::Resource::Supply::Blood::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
}

AMM::Resource::Supply::Clear_Liquid::Clear_Liquid()
{
    m_volume = 0.0;

}

AMM::Resource::Supply::Clear_Liquid::~Clear_Liquid()
{
}

AMM::Resource::Supply::Clear_Liquid::Clear_Liquid(const Clear_Liquid &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Clear_Liquid::Clear_Liquid(Clear_Liquid &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Clear_Liquid& AMM::Resource::Supply::Clear_Liquid::operator=(const Clear_Liquid &x)
{

    m_volume = x.m_volume;

    return *this;
}

AMM::Resource::Supply::Clear_Liquid& AMM::Resource::Supply::Clear_Liquid::operator=(Clear_Liquid &&x)
{

    m_volume = x.m_volume;

    return *this;
}

size_t AMM::Resource::Supply::Clear_Liquid::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Supply::Clear_Liquid::getCdrSerializedSize(const AMM::Resource::Supply::Clear_Liquid& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Supply::Clear_Liquid::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_volume;
}

void AMM::Resource::Supply::Clear_Liquid::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_volume;
}

/*!
 * @brief This function sets a value in member volume
 * @param _volume New value for member volume
 */
void AMM::Resource::Supply::Clear_Liquid::volume(double _volume)
{
m_volume = _volume;
}

/*!
 * @brief This function returns the value of member volume
 * @return Value of member volume
 */
double AMM::Resource::Supply::Clear_Liquid::volume() const
{
    return m_volume;
}

/*!
 * @brief This function returns a reference to member volume
 * @return Reference to member volume
 */
double& AMM::Resource::Supply::Clear_Liquid::volume()
{
    return m_volume;
}

size_t AMM::Resource::Supply::Clear_Liquid::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;



    return current_align;
}

bool AMM::Resource::Supply::Clear_Liquid::isKeyDefined()
{
   return false;
}

void AMM::Resource::Supply::Clear_Liquid::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
}

AMM::Resource::Supply::Air::Air()
{
    m_volume = 0.0;

}

AMM::Resource::Supply::Air::~Air()
{
}

AMM::Resource::Supply::Air::Air(const Air &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Air::Air(Air &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Air& AMM::Resource::Supply::Air::operator=(const Air &x)
{

    m_volume = x.m_volume;

    return *this;
}

AMM::Resource::Supply::Air& AMM::Resource::Supply::Air::operator=(Air &&x)
{

    m_volume = x.m_volume;

    return *this;
}

size_t AMM::Resource::Supply::Air::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Supply::Air::getCdrSerializedSize(const AMM::Resource::Supply::Air& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Supply::Air::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_volume;
}

void AMM::Resource::Supply::Air::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_volume;
}

/*!
 * @brief This function sets a value in member volume
 * @param _volume New value for member volume
 */
void AMM::Resource::Supply::Air::volume(double _volume)
{
m_volume = _volume;
}

/*!
 * @brief This function returns the value of member volume
 * @return Value of member volume
 */
double AMM::Resource::Supply::Air::volume() const
{
    return m_volume;
}

/*!
 * @brief This function returns a reference to member volume
 * @return Reference to member volume
 */
double& AMM::Resource::Supply::Air::volume()
{
    return m_volume;
}

size_t AMM::Resource::Supply::Air::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;



    return current_align;
}

bool AMM::Resource::Supply::Air::isKeyDefined()
{
   return false;
}

void AMM::Resource::Supply::Air::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
}

AMM::Resource::Supply::Cleaning_Solution::Cleaning_Solution()
{
    m_volume = 0.0;

}

AMM::Resource::Supply::Cleaning_Solution::~Cleaning_Solution()
{
}

AMM::Resource::Supply::Cleaning_Solution::Cleaning_Solution(const Cleaning_Solution &x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Cleaning_Solution::Cleaning_Solution(Cleaning_Solution &&x)
{
    m_volume = x.m_volume;
}

AMM::Resource::Supply::Cleaning_Solution& AMM::Resource::Supply::Cleaning_Solution::operator=(const Cleaning_Solution &x)
{

    m_volume = x.m_volume;

    return *this;
}

AMM::Resource::Supply::Cleaning_Solution& AMM::Resource::Supply::Cleaning_Solution::operator=(Cleaning_Solution &&x)
{

    m_volume = x.m_volume;

    return *this;
}

size_t AMM::Resource::Supply::Cleaning_Solution::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t AMM::Resource::Supply::Cleaning_Solution::getCdrSerializedSize(const AMM::Resource::Supply::Cleaning_Solution& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void AMM::Resource::Supply::Cleaning_Solution::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_volume;
}

void AMM::Resource::Supply::Cleaning_Solution::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_volume;
}

/*!
 * @brief This function sets a value in member volume
 * @param _volume New value for member volume
 */
void AMM::Resource::Supply::Cleaning_Solution::volume(double _volume)
{
m_volume = _volume;
}

/*!
 * @brief This function returns the value of member volume
 * @return Value of member volume
 */
double AMM::Resource::Supply::Cleaning_Solution::volume() const
{
    return m_volume;
}

/*!
 * @brief This function returns a reference to member volume
 * @return Reference to member volume
 */
double& AMM::Resource::Supply::Cleaning_Solution::volume()
{
    return m_volume;
}

size_t AMM::Resource::Supply::Cleaning_Solution::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;



    return current_align;
}

bool AMM::Resource::Supply::Cleaning_Solution::isKeyDefined()
{
   return false;
}

void AMM::Resource::Supply::Cleaning_Solution::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
}




AMM::Capability::Configuration::Configuration()
{








}

AMM::Capability::Configuration::~Configuration()
{







}

AMM::Capability::Configuration::Configuration(const Configuration &x)
{
    m_module_id = x.m_module_id;
    m_module_name = x.m_module_name;
    m_manufacturer = x.m_manufacturer;
    m_model = x.m_model;
    m_serial_number = x.m_serial_number;
    m_version = x.m_version;
    m_capabilities = x.m_capabilities;
}

AMM::Capability::Configuration::Configuration(Configuration &&x)
{
    m_module_id = std::move(x.m_module_id);
    m_module_name = std::move(x.m_module_name);
    m_manufacturer = std::move(x.m_manufacturer);
    m_model = std::move(x.m_model);
    m_serial_number = std::move(x.m_serial_number);
    m_version = std::move(x.m_version);
    m_capabilities = std::move(x.m_capabilities);
}

AMM::Capability::Configuration& AMM::Capability::Configuration::operator=(const Configuration &x)
{

    m_module_id = x.m_module_id;
    m_module_name = x.m_module_name;
    m_manufacturer = x.m_manufacturer;
    m_model = x.m_model;
    m_serial_number = x.m_serial_number;
    m_version = x.m_version;
    m_capabilities = x.m_capabilities;

    return *this;
}

AMM::Capability::Configuration& AMM::Capability::Configuration::operator=(Configuration &&x)
{

    m_module_id = std::move(x.m_module_id);
    m_module_name = std::move(x.m_module_name);
    m_manufacturer = std::move(x.m_manufacturer);
    m_model = std::move(x.m_model);
    m_serial_number = std::move(x.m_serial_number);
    m_version = std::move(x.m_version);
    m_capabilities = std::move(x.m_capabilities);

    return *this;
}

size_t AMM::Capability::Configuration::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Capability::Configuration::getCdrSerializedSize(const AMM::Capability::Configuration& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.module_id().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.module_name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.manufacturer().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.model().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.serial_number().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.version().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.capabilities().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Capability::Configuration::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_module_id;
    scdr << m_module_name;
    scdr << m_manufacturer;
    scdr << m_model;
    scdr << m_serial_number;
    scdr << m_version;
    scdr << m_capabilities;
}

void AMM::Capability::Configuration::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_module_id;
    dcdr >> m_module_name;
    dcdr >> m_manufacturer;
    dcdr >> m_model;
    dcdr >> m_serial_number;
    dcdr >> m_version;
    dcdr >> m_capabilities;
}

/*!
 * @brief This function copies the value in member module_id
 * @param _module_id New value to be copied in member module_id
 */
void AMM::Capability::Configuration::module_id(const std::string &_module_id)
{
m_module_id = _module_id;
}

/*!
 * @brief This function moves the value in member module_id
 * @param _module_id New value to be moved in member module_id
 */
void AMM::Capability::Configuration::module_id(std::string &&_module_id)
{
m_module_id = std::move(_module_id);
}

/*!
 * @brief This function returns a constant reference to member module_id
 * @return Constant reference to member module_id
 */
const std::string& AMM::Capability::Configuration::module_id() const
{
    return m_module_id;
}

/*!
 * @brief This function returns a reference to member module_id
 * @return Reference to member module_id
 */
std::string& AMM::Capability::Configuration::module_id()
{
    return m_module_id;
}
/*!
 * @brief This function copies the value in member module_name
 * @param _module_name New value to be copied in member module_name
 */
void AMM::Capability::Configuration::module_name(const std::string &_module_name)
{
m_module_name = _module_name;
}

/*!
 * @brief This function moves the value in member module_name
 * @param _module_name New value to be moved in member module_name
 */
void AMM::Capability::Configuration::module_name(std::string &&_module_name)
{
m_module_name = std::move(_module_name);
}

/*!
 * @brief This function returns a constant reference to member module_name
 * @return Constant reference to member module_name
 */
const std::string& AMM::Capability::Configuration::module_name() const
{
    return m_module_name;
}

/*!
 * @brief This function returns a reference to member module_name
 * @return Reference to member module_name
 */
std::string& AMM::Capability::Configuration::module_name()
{
    return m_module_name;
}
/*!
 * @brief This function copies the value in member manufacturer
 * @param _manufacturer New value to be copied in member manufacturer
 */
void AMM::Capability::Configuration::manufacturer(const std::string &_manufacturer)
{
m_manufacturer = _manufacturer;
}

/*!
 * @brief This function moves the value in member manufacturer
 * @param _manufacturer New value to be moved in member manufacturer
 */
void AMM::Capability::Configuration::manufacturer(std::string &&_manufacturer)
{
m_manufacturer = std::move(_manufacturer);
}

/*!
 * @brief This function returns a constant reference to member manufacturer
 * @return Constant reference to member manufacturer
 */
const std::string& AMM::Capability::Configuration::manufacturer() const
{
    return m_manufacturer;
}

/*!
 * @brief This function returns a reference to member manufacturer
 * @return Reference to member manufacturer
 */
std::string& AMM::Capability::Configuration::manufacturer()
{
    return m_manufacturer;
}
/*!
 * @brief This function copies the value in member model
 * @param _model New value to be copied in member model
 */
void AMM::Capability::Configuration::model(const std::string &_model)
{
m_model = _model;
}

/*!
 * @brief This function moves the value in member model
 * @param _model New value to be moved in member model
 */
void AMM::Capability::Configuration::model(std::string &&_model)
{
m_model = std::move(_model);
}

/*!
 * @brief This function returns a constant reference to member model
 * @return Constant reference to member model
 */
const std::string& AMM::Capability::Configuration::model() const
{
    return m_model;
}

/*!
 * @brief This function returns a reference to member model
 * @return Reference to member model
 */
std::string& AMM::Capability::Configuration::model()
{
    return m_model;
}
/*!
 * @brief This function copies the value in member serial_number
 * @param _serial_number New value to be copied in member serial_number
 */
void AMM::Capability::Configuration::serial_number(const std::string &_serial_number)
{
m_serial_number = _serial_number;
}

/*!
 * @brief This function moves the value in member serial_number
 * @param _serial_number New value to be moved in member serial_number
 */
void AMM::Capability::Configuration::serial_number(std::string &&_serial_number)
{
m_serial_number = std::move(_serial_number);
}

/*!
 * @brief This function returns a constant reference to member serial_number
 * @return Constant reference to member serial_number
 */
const std::string& AMM::Capability::Configuration::serial_number() const
{
    return m_serial_number;
}

/*!
 * @brief This function returns a reference to member serial_number
 * @return Reference to member serial_number
 */
std::string& AMM::Capability::Configuration::serial_number()
{
    return m_serial_number;
}
/*!
 * @brief This function copies the value in member version
 * @param _version New value to be copied in member version
 */
void AMM::Capability::Configuration::version(const std::string &_version)
{
m_version = _version;
}

/*!
 * @brief This function moves the value in member version
 * @param _version New value to be moved in member version
 */
void AMM::Capability::Configuration::version(std::string &&_version)
{
m_version = std::move(_version);
}

/*!
 * @brief This function returns a constant reference to member version
 * @return Constant reference to member version
 */
const std::string& AMM::Capability::Configuration::version() const
{
    return m_version;
}

/*!
 * @brief This function returns a reference to member version
 * @return Reference to member version
 */
std::string& AMM::Capability::Configuration::version()
{
    return m_version;
}
/*!
 * @brief This function copies the value in member capabilities
 * @param _capabilities New value to be copied in member capabilities
 */
void AMM::Capability::Configuration::capabilities(const std::string &_capabilities)
{
m_capabilities = _capabilities;
}

/*!
 * @brief This function moves the value in member capabilities
 * @param _capabilities New value to be moved in member capabilities
 */
void AMM::Capability::Configuration::capabilities(std::string &&_capabilities)
{
m_capabilities = std::move(_capabilities);
}

/*!
 * @brief This function returns a constant reference to member capabilities
 * @return Constant reference to member capabilities
 */
const std::string& AMM::Capability::Configuration::capabilities() const
{
    return m_capabilities;
}

/*!
 * @brief This function returns a reference to member capabilities
 * @return Reference to member capabilities
 */
std::string& AMM::Capability::Configuration::capabilities()
{
    return m_capabilities;
}

size_t AMM::Capability::Configuration::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;










    return current_align;
}

bool AMM::Capability::Configuration::isKeyDefined()
{
   return false;
}

void AMM::Capability::Configuration::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
	 
	 
}

AMM::Capability::Scenario::Scenario()
{

}

AMM::Capability::Scenario::~Scenario()
{
}

AMM::Capability::Scenario::Scenario(const Scenario &x)
{
    m_id = x.m_id;
}

AMM::Capability::Scenario::Scenario(Scenario &&x)
{
    m_id = std::move(x.m_id);
}

AMM::Capability::Scenario& AMM::Capability::Scenario::operator=(const Scenario &x)
{

    m_id = x.m_id;

    return *this;
}

AMM::Capability::Scenario& AMM::Capability::Scenario::operator=(Scenario &&x)
{

    m_id = std::move(x.m_id);

    return *this;
}

size_t AMM::Capability::Scenario::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t AMM::Capability::Scenario::getCdrSerializedSize(const AMM::Capability::Scenario& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.id().size() + 1;

    return current_alignment - initial_alignment;
}

void AMM::Capability::Scenario::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_id;
}

void AMM::Capability::Scenario::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_id;
}

/*!
 * @brief This function copies the value in member id
 * @param _id New value to be copied in member id
 */
void AMM::Capability::Scenario::id(const std::string &_id)
{
m_id = _id;
}

/*!
 * @brief This function moves the value in member id
 * @param _id New value to be moved in member id
 */
void AMM::Capability::Scenario::id(std::string &&_id)
{
m_id = std::move(_id);
}

/*!
 * @brief This function returns a constant reference to member id
 * @return Constant reference to member id
 */
const std::string& AMM::Capability::Scenario::id() const
{
    return m_id;
}

/*!
 * @brief This function returns a reference to member id
 * @return Reference to member id
 */
std::string& AMM::Capability::Scenario::id()
{
    return m_id;
}

size_t AMM::Capability::Scenario::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;



    return current_align;
}

bool AMM::Capability::Scenario::isKeyDefined()
{
   return false;
}

void AMM::Capability::Scenario::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
}

AMM::Capability::Status::Status()
{



    m_status_value = AMM::Capability::OPERATIONAL;


}

AMM::Capability::Status::~Status()
{





}

AMM::Capability::Status::Status(const Status &x)
{
    m_module_id = x.m_module_id;
    m_module_name = x.m_module_name;
    m_capability = x.m_capability;
    m_status_value = x.m_status_value;
    m_message = x.m_message;
}

AMM::Capability::Status::Status(Status &&x)
{
    m_module_id = std::move(x.m_module_id);
    m_module_name = std::move(x.m_module_name);
    m_capability = std::move(x.m_capability);
    m_status_value = x.m_status_value;
    m_message = std::move(x.m_message);
}

AMM::Capability::Status& AMM::Capability::Status::operator=(const Status &x)
{

    m_module_id = x.m_module_id;
    m_module_name = x.m_module_name;
    m_capability = x.m_capability;
    m_status_value = x.m_status_value;
    m_message = x.m_message;

    return *this;
}

AMM::Capability::Status& AMM::Capability::Status::operator=(Status &&x)
{

    m_module_id = std::move(x.m_module_id);
    m_module_name = std::move(x.m_module_name);
    m_capability = std::move(x.m_capability);
    m_status_value = x.m_status_value;
    m_message = std::move(x.m_message);

    return *this;
}

size_t AMM::Capability::Status::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;
    }

    return current_alignment - initial_alignment;
}

size_t AMM::Capability::Status::getCdrSerializedSize(const AMM::Capability::Status& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.module_id().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.module_name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.capability().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    for(size_t a = 0; a < data.message().size(); ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.message().at(a).size() + 1;
    }

    return current_alignment - initial_alignment;
}

void AMM::Capability::Status::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_module_id;
    scdr << m_module_name;
    scdr << m_capability;
    scdr << (uint32_t)m_status_value;
    scdr << m_message;
}

void AMM::Capability::Status::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_module_id;
    dcdr >> m_module_name;
    dcdr >> m_capability;
    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        m_status_value = (AMM::Capability::status_values)enum_value;
    }

    dcdr >> m_message;
}

/*!
 * @brief This function copies the value in member module_id
 * @param _module_id New value to be copied in member module_id
 */
void AMM::Capability::Status::module_id(const std::string &_module_id)
{
m_module_id = _module_id;
}

/*!
 * @brief This function moves the value in member module_id
 * @param _module_id New value to be moved in member module_id
 */
void AMM::Capability::Status::module_id(std::string &&_module_id)
{
m_module_id = std::move(_module_id);
}

/*!
 * @brief This function returns a constant reference to member module_id
 * @return Constant reference to member module_id
 */
const std::string& AMM::Capability::Status::module_id() const
{
    return m_module_id;
}

/*!
 * @brief This function returns a reference to member module_id
 * @return Reference to member module_id
 */
std::string& AMM::Capability::Status::module_id()
{
    return m_module_id;
}
/*!
 * @brief This function copies the value in member module_name
 * @param _module_name New value to be copied in member module_name
 */
void AMM::Capability::Status::module_name(const std::string &_module_name)
{
m_module_name = _module_name;
}

/*!
 * @brief This function moves the value in member module_name
 * @param _module_name New value to be moved in member module_name
 */
void AMM::Capability::Status::module_name(std::string &&_module_name)
{
m_module_name = std::move(_module_name);
}

/*!
 * @brief This function returns a constant reference to member module_name
 * @return Constant reference to member module_name
 */
const std::string& AMM::Capability::Status::module_name() const
{
    return m_module_name;
}

/*!
 * @brief This function returns a reference to member module_name
 * @return Reference to member module_name
 */
std::string& AMM::Capability::Status::module_name()
{
    return m_module_name;
}
/*!
 * @brief This function copies the value in member capability
 * @param _capability New value to be copied in member capability
 */
void AMM::Capability::Status::capability(const std::string &_capability)
{
m_capability = _capability;
}

/*!
 * @brief This function moves the value in member capability
 * @param _capability New value to be moved in member capability
 */
void AMM::Capability::Status::capability(std::string &&_capability)
{
m_capability = std::move(_capability);
}

/*!
 * @brief This function returns a constant reference to member capability
 * @return Constant reference to member capability
 */
const std::string& AMM::Capability::Status::capability() const
{
    return m_capability;
}

/*!
 * @brief This function returns a reference to member capability
 * @return Reference to member capability
 */
std::string& AMM::Capability::Status::capability()
{
    return m_capability;
}
/*!
 * @brief This function sets a value in member status_value
 * @param _status_value New value for member status_value
 */
void AMM::Capability::Status::status_value(AMM::Capability::status_values _status_value)
{
m_status_value = _status_value;
}

/*!
 * @brief This function returns the value of member status_value
 * @return Value of member status_value
 */
AMM::Capability::status_values AMM::Capability::Status::status_value() const
{
    return m_status_value;
}

/*!
 * @brief This function returns a reference to member status_value
 * @return Reference to member status_value
 */
AMM::Capability::status_values& AMM::Capability::Status::status_value()
{
    return m_status_value;
}
/*!
 * @brief This function copies the value in member message
 * @param _message New value to be copied in member message
 */
void AMM::Capability::Status::message(const std::vector<std::string> &_message)
{
m_message = _message;
}

/*!
 * @brief This function moves the value in member message
 * @param _message New value to be moved in member message
 */
void AMM::Capability::Status::message(std::vector<std::string> &&_message)
{
m_message = std::move(_message);
}

/*!
 * @brief This function returns a constant reference to member message
 * @return Constant reference to member message
 */
const std::vector<std::string>& AMM::Capability::Status::message() const
{
    return m_message;
}

/*!
 * @brief This function returns a reference to member message
 * @return Reference to member message
 */
std::vector<std::string>& AMM::Capability::Status::message()
{
    return m_message;
}

size_t AMM::Capability::Status::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;








    return current_align;
}

bool AMM::Capability::Status::isKeyDefined()
{
   return false;
}

void AMM::Capability::Status::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
}


AMM::Diagnostics::Log::Record::Record()
{
    m_timestamp = 0;





}

AMM::Diagnostics::Log::Record::~Record()
{





}

AMM::Diagnostics::Log::Record::Record(const Record &x)
{
    m_timestamp = x.m_timestamp;
    m_log_level = x.m_log_level;
    m_message = x.m_message;
    m_module_name = x.m_module_name;
    m_module_id = x.m_module_id;
}

AMM::Diagnostics::Log::Record::Record(Record &&x)
{
    m_timestamp = x.m_timestamp;
    m_log_level = std::move(x.m_log_level);
    m_message = std::move(x.m_message);
    m_module_name = std::move(x.m_module_name);
    m_module_id = std::move(x.m_module_id);
}

AMM::Diagnostics::Log::Record& AMM::Diagnostics::Log::Record::operator=(const Record &x)
{

    m_timestamp = x.m_timestamp;
    m_log_level = x.m_log_level;
    m_message = x.m_message;
    m_module_name = x.m_module_name;
    m_module_id = x.m_module_id;

    return *this;
}

AMM::Diagnostics::Log::Record& AMM::Diagnostics::Log::Record::operator=(Record &&x)
{

    m_timestamp = x.m_timestamp;
    m_log_level = std::move(x.m_log_level);
    m_message = std::move(x.m_message);
    m_module_name = std::move(x.m_module_name);
    m_module_id = std::move(x.m_module_id);

    return *this;
}

size_t AMM::Diagnostics::Log::Record::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t AMM::Diagnostics::Log::Record::getCdrSerializedSize(const AMM::Diagnostics::Log::Record& data, size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.log_level().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.message().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.module_name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.module_id().size() + 1;


    return current_alignment - initial_alignment;
}

void AMM::Diagnostics::Log::Record::serialize(eprosima::fastcdr::Cdr &scdr) const
{

    scdr << m_timestamp;
    scdr << m_log_level;
    scdr << m_message;
    scdr << m_module_name;
    scdr << m_module_id;
}

void AMM::Diagnostics::Log::Record::deserialize(eprosima::fastcdr::Cdr &dcdr)
{

    dcdr >> m_timestamp;
    dcdr >> m_log_level;
    dcdr >> m_message;
    dcdr >> m_module_name;
    dcdr >> m_module_id;
}

/*!
 * @brief This function sets a value in member timestamp
 * @param _timestamp New value for member timestamp
 */
void AMM::Diagnostics::Log::Record::timestamp(uint64_t _timestamp)
{
m_timestamp = _timestamp;
}

/*!
 * @brief This function returns the value of member timestamp
 * @return Value of member timestamp
 */
uint64_t AMM::Diagnostics::Log::Record::timestamp() const
{
    return m_timestamp;
}

/*!
 * @brief This function returns a reference to member timestamp
 * @return Reference to member timestamp
 */
uint64_t& AMM::Diagnostics::Log::Record::timestamp()
{
    return m_timestamp;
}
/*!
 * @brief This function copies the value in member log_level
 * @param _log_level New value to be copied in member log_level
 */
void AMM::Diagnostics::Log::Record::log_level(const std::string &_log_level)
{
m_log_level = _log_level;
}

/*!
 * @brief This function moves the value in member log_level
 * @param _log_level New value to be moved in member log_level
 */
void AMM::Diagnostics::Log::Record::log_level(std::string &&_log_level)
{
m_log_level = std::move(_log_level);
}

/*!
 * @brief This function returns a constant reference to member log_level
 * @return Constant reference to member log_level
 */
const std::string& AMM::Diagnostics::Log::Record::log_level() const
{
    return m_log_level;
}

/*!
 * @brief This function returns a reference to member log_level
 * @return Reference to member log_level
 */
std::string& AMM::Diagnostics::Log::Record::log_level()
{
    return m_log_level;
}
/*!
 * @brief This function copies the value in member message
 * @param _message New value to be copied in member message
 */
void AMM::Diagnostics::Log::Record::message(const std::string &_message)
{
m_message = _message;
}

/*!
 * @brief This function moves the value in member message
 * @param _message New value to be moved in member message
 */
void AMM::Diagnostics::Log::Record::message(std::string &&_message)
{
m_message = std::move(_message);
}

/*!
 * @brief This function returns a constant reference to member message
 * @return Constant reference to member message
 */
const std::string& AMM::Diagnostics::Log::Record::message() const
{
    return m_message;
}

/*!
 * @brief This function returns a reference to member message
 * @return Reference to member message
 */
std::string& AMM::Diagnostics::Log::Record::message()
{
    return m_message;
}
/*!
 * @brief This function copies the value in member module_name
 * @param _module_name New value to be copied in member module_name
 */
void AMM::Diagnostics::Log::Record::module_name(const std::string &_module_name)
{
m_module_name = _module_name;
}

/*!
 * @brief This function moves the value in member module_name
 * @param _module_name New value to be moved in member module_name
 */
void AMM::Diagnostics::Log::Record::module_name(std::string &&_module_name)
{
m_module_name = std::move(_module_name);
}

/*!
 * @brief This function returns a constant reference to member module_name
 * @return Constant reference to member module_name
 */
const std::string& AMM::Diagnostics::Log::Record::module_name() const
{
    return m_module_name;
}

/*!
 * @brief This function returns a reference to member module_name
 * @return Reference to member module_name
 */
std::string& AMM::Diagnostics::Log::Record::module_name()
{
    return m_module_name;
}
/*!
 * @brief This function copies the value in member module_id
 * @param _module_id New value to be copied in member module_id
 */
void AMM::Diagnostics::Log::Record::module_id(const std::string &_module_id)
{
m_module_id = _module_id;
}

/*!
 * @brief This function moves the value in member module_id
 * @param _module_id New value to be moved in member module_id
 */
void AMM::Diagnostics::Log::Record::module_id(std::string &&_module_id)
{
m_module_id = std::move(_module_id);
}

/*!
 * @brief This function returns a constant reference to member module_id
 * @return Constant reference to member module_id
 */
const std::string& AMM::Diagnostics::Log::Record::module_id() const
{
    return m_module_id;
}

/*!
 * @brief This function returns a reference to member module_id
 * @return Reference to member module_id
 */
std::string& AMM::Diagnostics::Log::Record::module_id()
{
    return m_module_id;
}

size_t AMM::Diagnostics::Log::Record::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;








    return current_align;
}

bool AMM::Diagnostics::Log::Record::isKeyDefined()
{
   return false;
}

void AMM::Diagnostics::Log::Record::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	(void) scdr;
	 
	 
	 
	 
	 
}



